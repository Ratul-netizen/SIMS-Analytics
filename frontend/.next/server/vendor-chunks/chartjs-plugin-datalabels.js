"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/chartjs-plugin-datalabels";
exports.ids = ["vendor-chunks/chartjs-plugin-datalabels"];
exports.modules = {

/***/ "(ssr)/./node_modules/chartjs-plugin-datalabels/dist/chartjs-plugin-datalabels.esm.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/chartjs-plugin-datalabels/dist/chartjs-plugin-datalabels.esm.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ plugin)\n/* harmony export */ });\n/* harmony import */ var chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chart.js/helpers */ \"(ssr)/./node_modules/chart.js/helpers/helpers.js\");\n/* harmony import */ var chart_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! chart.js */ \"(ssr)/./node_modules/chart.js/dist/chart.js\");\n/* harmony import */ var chart_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! chart.js */ \"(ssr)/./node_modules/chart.js/dist/chunks/helpers.dataset.js\");\n/*!\n * chartjs-plugin-datalabels v2.2.0\n * https://chartjs-plugin-datalabels.netlify.app\n * (c) 2017-2022 chartjs-plugin-datalabels contributors\n * Released under the MIT license\n */ \n\nvar devicePixelRatio = function() {\n    if (false) { var screen; }\n    return 1;\n}();\nvar utils = {\n    // @todo move this in Chart.helpers.toTextLines\n    toTextLines: function(inputs) {\n        var lines = [];\n        var input;\n        inputs = [].concat(inputs);\n        while(inputs.length){\n            input = inputs.pop();\n            if (typeof input === \"string\") {\n                lines.unshift.apply(lines, input.split(\"\\n\"));\n            } else if (Array.isArray(input)) {\n                inputs.push.apply(inputs, input);\n            } else if (!(0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndef)(inputs)) {\n                lines.unshift(\"\" + input);\n            }\n        }\n        return lines;\n    },\n    // @todo move this in Chart.helpers.canvas.textSize\n    // @todo cache calls of measureText if font doesn't change?!\n    textSize: function(ctx, lines, font) {\n        var items = [].concat(lines);\n        var ilen = items.length;\n        var prev = ctx.font;\n        var width = 0;\n        var i;\n        ctx.font = font.string;\n        for(i = 0; i < ilen; ++i){\n            width = Math.max(ctx.measureText(items[i]).width, width);\n        }\n        ctx.font = prev;\n        return {\n            height: ilen * font.lineHeight,\n            width: width\n        };\n    },\n    /**\n   * Returns value bounded by min and max. This is equivalent to max(min, min(value, max)).\n   * @todo move this method in Chart.helpers.bound\n   * https://doc.qt.io/qt-5/qtglobal.html#qBound\n   */ bound: function(min, value, max) {\n        return Math.max(min, Math.min(value, max));\n    },\n    /**\n   * Returns an array of pair [value, state] where state is:\n   * * -1: value is only in a0 (removed)\n   * *  1: value is only in a1 (added)\n   */ arrayDiff: function(a0, a1) {\n        var prev = a0.slice();\n        var updates = [];\n        var i, j, ilen, v;\n        for(i = 0, ilen = a1.length; i < ilen; ++i){\n            v = a1[i];\n            j = prev.indexOf(v);\n            if (j === -1) {\n                updates.push([\n                    v,\n                    1\n                ]);\n            } else {\n                prev.splice(j, 1);\n            }\n        }\n        for(i = 0, ilen = prev.length; i < ilen; ++i){\n            updates.push([\n                prev[i],\n                -1\n            ]);\n        }\n        return updates;\n    },\n    /**\n   * https://github.com/chartjs/chartjs-plugin-datalabels/issues/70\n   */ rasterize: function(v) {\n        return Math.round(v * devicePixelRatio) / devicePixelRatio;\n    }\n};\nfunction orient(point, origin) {\n    var x0 = origin.x;\n    var y0 = origin.y;\n    if (x0 === null) {\n        return {\n            x: 0,\n            y: -1\n        };\n    }\n    if (y0 === null) {\n        return {\n            x: 1,\n            y: 0\n        };\n    }\n    var dx = point.x - x0;\n    var dy = point.y - y0;\n    var ln = Math.sqrt(dx * dx + dy * dy);\n    return {\n        x: ln ? dx / ln : 0,\n        y: ln ? dy / ln : -1\n    };\n}\nfunction aligned(x, y, vx, vy, align) {\n    switch(align){\n        case \"center\":\n            vx = vy = 0;\n            break;\n        case \"bottom\":\n            vx = 0;\n            vy = 1;\n            break;\n        case \"right\":\n            vx = 1;\n            vy = 0;\n            break;\n        case \"left\":\n            vx = -1;\n            vy = 0;\n            break;\n        case \"top\":\n            vx = 0;\n            vy = -1;\n            break;\n        case \"start\":\n            vx = -vx;\n            vy = -vy;\n            break;\n        case \"end\":\n            break;\n        default:\n            // clockwise rotation (in degree)\n            align *= Math.PI / 180;\n            vx = Math.cos(align);\n            vy = Math.sin(align);\n            break;\n    }\n    return {\n        x: x,\n        y: y,\n        vx: vx,\n        vy: vy\n    };\n}\n// Line clipping (Cohen–Sutherland algorithm)\n// https://en.wikipedia.org/wiki/Cohen–Sutherland_algorithm\nvar R_INSIDE = 0;\nvar R_LEFT = 1;\nvar R_RIGHT = 2;\nvar R_BOTTOM = 4;\nvar R_TOP = 8;\nfunction region(x, y, rect) {\n    var res = R_INSIDE;\n    if (x < rect.left) {\n        res |= R_LEFT;\n    } else if (x > rect.right) {\n        res |= R_RIGHT;\n    }\n    if (y < rect.top) {\n        res |= R_TOP;\n    } else if (y > rect.bottom) {\n        res |= R_BOTTOM;\n    }\n    return res;\n}\nfunction clipped(segment, area) {\n    var x0 = segment.x0;\n    var y0 = segment.y0;\n    var x1 = segment.x1;\n    var y1 = segment.y1;\n    var r0 = region(x0, y0, area);\n    var r1 = region(x1, y1, area);\n    var r, x, y;\n    // eslint-disable-next-line no-constant-condition\n    while(true){\n        if (!(r0 | r1) || r0 & r1) {\n            break;\n        }\n        // at least one point is outside\n        r = r0 || r1;\n        if (r & R_TOP) {\n            x = x0 + (x1 - x0) * (area.top - y0) / (y1 - y0);\n            y = area.top;\n        } else if (r & R_BOTTOM) {\n            x = x0 + (x1 - x0) * (area.bottom - y0) / (y1 - y0);\n            y = area.bottom;\n        } else if (r & R_RIGHT) {\n            y = y0 + (y1 - y0) * (area.right - x0) / (x1 - x0);\n            x = area.right;\n        } else if (r & R_LEFT) {\n            y = y0 + (y1 - y0) * (area.left - x0) / (x1 - x0);\n            x = area.left;\n        }\n        if (r === r0) {\n            x0 = x;\n            y0 = y;\n            r0 = region(x0, y0, area);\n        } else {\n            x1 = x;\n            y1 = y;\n            r1 = region(x1, y1, area);\n        }\n    }\n    return {\n        x0: x0,\n        x1: x1,\n        y0: y0,\n        y1: y1\n    };\n}\nfunction compute$1(range, config) {\n    var anchor = config.anchor;\n    var segment = range;\n    var x, y;\n    if (config.clamp) {\n        segment = clipped(segment, config.area);\n    }\n    if (anchor === \"start\") {\n        x = segment.x0;\n        y = segment.y0;\n    } else if (anchor === \"end\") {\n        x = segment.x1;\n        y = segment.y1;\n    } else {\n        x = (segment.x0 + segment.x1) / 2;\n        y = (segment.y0 + segment.y1) / 2;\n    }\n    return aligned(x, y, range.vx, range.vy, config.align);\n}\nvar positioners = {\n    arc: function(el, config) {\n        var angle = (el.startAngle + el.endAngle) / 2;\n        var vx = Math.cos(angle);\n        var vy = Math.sin(angle);\n        var r0 = el.innerRadius;\n        var r1 = el.outerRadius;\n        return compute$1({\n            x0: el.x + vx * r0,\n            y0: el.y + vy * r0,\n            x1: el.x + vx * r1,\n            y1: el.y + vy * r1,\n            vx: vx,\n            vy: vy\n        }, config);\n    },\n    point: function(el, config) {\n        var v = orient(el, config.origin);\n        var rx = v.x * el.options.radius;\n        var ry = v.y * el.options.radius;\n        return compute$1({\n            x0: el.x - rx,\n            y0: el.y - ry,\n            x1: el.x + rx,\n            y1: el.y + ry,\n            vx: v.x,\n            vy: v.y\n        }, config);\n    },\n    bar: function(el, config) {\n        var v = orient(el, config.origin);\n        var x = el.x;\n        var y = el.y;\n        var sx = 0;\n        var sy = 0;\n        if (el.horizontal) {\n            x = Math.min(el.x, el.base);\n            sx = Math.abs(el.base - el.x);\n        } else {\n            y = Math.min(el.y, el.base);\n            sy = Math.abs(el.base - el.y);\n        }\n        return compute$1({\n            x0: x,\n            y0: y + sy,\n            x1: x + sx,\n            y1: y,\n            vx: v.x,\n            vy: v.y\n        }, config);\n    },\n    fallback: function(el, config) {\n        var v = orient(el, config.origin);\n        return compute$1({\n            x0: el.x,\n            y0: el.y,\n            x1: el.x + (el.width || 0),\n            y1: el.y + (el.height || 0),\n            vx: v.x,\n            vy: v.y\n        }, config);\n    }\n};\nvar rasterize = utils.rasterize;\nfunction boundingRects(model) {\n    var borderWidth = model.borderWidth || 0;\n    var padding = model.padding;\n    var th = model.size.height;\n    var tw = model.size.width;\n    var tx = -tw / 2;\n    var ty = -th / 2;\n    return {\n        frame: {\n            x: tx - padding.left - borderWidth,\n            y: ty - padding.top - borderWidth,\n            w: tw + padding.width + borderWidth * 2,\n            h: th + padding.height + borderWidth * 2\n        },\n        text: {\n            x: tx,\n            y: ty,\n            w: tw,\n            h: th\n        }\n    };\n}\nfunction getScaleOrigin(el, context) {\n    var scale = context.chart.getDatasetMeta(context.datasetIndex).vScale;\n    if (!scale) {\n        return null;\n    }\n    if (scale.xCenter !== undefined && scale.yCenter !== undefined) {\n        return {\n            x: scale.xCenter,\n            y: scale.yCenter\n        };\n    }\n    var pixel = scale.getBasePixel();\n    return el.horizontal ? {\n        x: pixel,\n        y: null\n    } : {\n        x: null,\n        y: pixel\n    };\n}\nfunction getPositioner(el) {\n    if (el instanceof chart_js__WEBPACK_IMPORTED_MODULE_1__.ArcElement) {\n        return positioners.arc;\n    }\n    if (el instanceof chart_js__WEBPACK_IMPORTED_MODULE_1__.PointElement) {\n        return positioners.point;\n    }\n    if (el instanceof chart_js__WEBPACK_IMPORTED_MODULE_1__.BarElement) {\n        return positioners.bar;\n    }\n    return positioners.fallback;\n}\nfunction drawRoundedRect(ctx, x, y, w, h, radius) {\n    var HALF_PI = Math.PI / 2;\n    if (radius) {\n        var r = Math.min(radius, h / 2, w / 2);\n        var left = x + r;\n        var top = y + r;\n        var right = x + w - r;\n        var bottom = y + h - r;\n        ctx.moveTo(x, top);\n        if (left < right && top < bottom) {\n            ctx.arc(left, top, r, -Math.PI, -HALF_PI);\n            ctx.arc(right, top, r, -HALF_PI, 0);\n            ctx.arc(right, bottom, r, 0, HALF_PI);\n            ctx.arc(left, bottom, r, HALF_PI, Math.PI);\n        } else if (left < right) {\n            ctx.moveTo(left, y);\n            ctx.arc(right, top, r, -HALF_PI, HALF_PI);\n            ctx.arc(left, top, r, HALF_PI, Math.PI + HALF_PI);\n        } else if (top < bottom) {\n            ctx.arc(left, top, r, -Math.PI, 0);\n            ctx.arc(left, bottom, r, 0, Math.PI);\n        } else {\n            ctx.arc(left, top, r, -Math.PI, Math.PI);\n        }\n        ctx.closePath();\n        ctx.moveTo(x, y);\n    } else {\n        ctx.rect(x, y, w, h);\n    }\n}\nfunction drawFrame(ctx, rect, model) {\n    var bgColor = model.backgroundColor;\n    var borderColor = model.borderColor;\n    var borderWidth = model.borderWidth;\n    if (!bgColor && (!borderColor || !borderWidth)) {\n        return;\n    }\n    ctx.beginPath();\n    drawRoundedRect(ctx, rasterize(rect.x) + borderWidth / 2, rasterize(rect.y) + borderWidth / 2, rasterize(rect.w) - borderWidth, rasterize(rect.h) - borderWidth, model.borderRadius);\n    ctx.closePath();\n    if (bgColor) {\n        ctx.fillStyle = bgColor;\n        ctx.fill();\n    }\n    if (borderColor && borderWidth) {\n        ctx.strokeStyle = borderColor;\n        ctx.lineWidth = borderWidth;\n        ctx.lineJoin = \"miter\";\n        ctx.stroke();\n    }\n}\nfunction textGeometry(rect, align, font) {\n    var h = font.lineHeight;\n    var w = rect.w;\n    var x = rect.x;\n    var y = rect.y + h / 2;\n    if (align === \"center\") {\n        x += w / 2;\n    } else if (align === \"end\" || align === \"right\") {\n        x += w;\n    }\n    return {\n        h: h,\n        w: w,\n        x: x,\n        y: y\n    };\n}\nfunction drawTextLine(ctx, text, cfg) {\n    var shadow = ctx.shadowBlur;\n    var stroked = cfg.stroked;\n    var x = rasterize(cfg.x);\n    var y = rasterize(cfg.y);\n    var w = rasterize(cfg.w);\n    if (stroked) {\n        ctx.strokeText(text, x, y, w);\n    }\n    if (cfg.filled) {\n        if (shadow && stroked) {\n            // Prevent drawing shadow on both the text stroke and fill, so\n            // if the text is stroked, remove the shadow for the text fill.\n            ctx.shadowBlur = 0;\n        }\n        ctx.fillText(text, x, y, w);\n        if (shadow && stroked) {\n            ctx.shadowBlur = shadow;\n        }\n    }\n}\nfunction drawText(ctx, lines, rect, model) {\n    var align = model.textAlign;\n    var color = model.color;\n    var filled = !!color;\n    var font = model.font;\n    var ilen = lines.length;\n    var strokeColor = model.textStrokeColor;\n    var strokeWidth = model.textStrokeWidth;\n    var stroked = strokeColor && strokeWidth;\n    var i;\n    if (!ilen || !filled && !stroked) {\n        return;\n    }\n    // Adjust coordinates based on text alignment and line height\n    rect = textGeometry(rect, align, font);\n    ctx.font = font.string;\n    ctx.textAlign = align;\n    ctx.textBaseline = \"middle\";\n    ctx.shadowBlur = model.textShadowBlur;\n    ctx.shadowColor = model.textShadowColor;\n    if (filled) {\n        ctx.fillStyle = color;\n    }\n    if (stroked) {\n        ctx.lineJoin = \"round\";\n        ctx.lineWidth = strokeWidth;\n        ctx.strokeStyle = strokeColor;\n    }\n    for(i = 0, ilen = lines.length; i < ilen; ++i){\n        drawTextLine(ctx, lines[i], {\n            stroked: stroked,\n            filled: filled,\n            w: rect.w,\n            x: rect.x,\n            y: rect.y + rect.h * i\n        });\n    }\n}\nvar Label = function(config, ctx, el, index) {\n    var me = this;\n    me._config = config;\n    me._index = index;\n    me._model = null;\n    me._rects = null;\n    me._ctx = ctx;\n    me._el = el;\n};\n(0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.merge)(Label.prototype, {\n    /**\n   * @private\n   */ _modelize: function(display, lines, config, context) {\n        var me = this;\n        var index = me._index;\n        var font = (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.toFont)((0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)([\n            config.font,\n            {}\n        ], context, index));\n        var color = (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)([\n            config.color,\n            chart_js__WEBPACK_IMPORTED_MODULE_2__.d.color\n        ], context, index);\n        return {\n            align: (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)([\n                config.align,\n                \"center\"\n            ], context, index),\n            anchor: (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)([\n                config.anchor,\n                \"center\"\n            ], context, index),\n            area: context.chart.chartArea,\n            backgroundColor: (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)([\n                config.backgroundColor,\n                null\n            ], context, index),\n            borderColor: (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)([\n                config.borderColor,\n                null\n            ], context, index),\n            borderRadius: (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)([\n                config.borderRadius,\n                0\n            ], context, index),\n            borderWidth: (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)([\n                config.borderWidth,\n                0\n            ], context, index),\n            clamp: (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)([\n                config.clamp,\n                false\n            ], context, index),\n            clip: (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)([\n                config.clip,\n                false\n            ], context, index),\n            color: color,\n            display: display,\n            font: font,\n            lines: lines,\n            offset: (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)([\n                config.offset,\n                4\n            ], context, index),\n            opacity: (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)([\n                config.opacity,\n                1\n            ], context, index),\n            origin: getScaleOrigin(me._el, context),\n            padding: (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.toPadding)((0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)([\n                config.padding,\n                4\n            ], context, index)),\n            positioner: getPositioner(me._el),\n            rotation: (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)([\n                config.rotation,\n                0\n            ], context, index) * (Math.PI / 180),\n            size: utils.textSize(me._ctx, lines, font),\n            textAlign: (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)([\n                config.textAlign,\n                \"start\"\n            ], context, index),\n            textShadowBlur: (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)([\n                config.textShadowBlur,\n                0\n            ], context, index),\n            textShadowColor: (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)([\n                config.textShadowColor,\n                color\n            ], context, index),\n            textStrokeColor: (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)([\n                config.textStrokeColor,\n                color\n            ], context, index),\n            textStrokeWidth: (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)([\n                config.textStrokeWidth,\n                0\n            ], context, index)\n        };\n    },\n    update: function(context) {\n        var me = this;\n        var model = null;\n        var rects = null;\n        var index = me._index;\n        var config = me._config;\n        var value, label, lines;\n        // We first resolve the display option (separately) to avoid computing\n        // other options in case the label is hidden (i.e. display: false).\n        var display = (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)([\n            config.display,\n            true\n        ], context, index);\n        if (display) {\n            value = context.dataset.data[index];\n            label = (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.valueOrDefault)((0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.callback)(config.formatter, [\n                value,\n                context\n            ]), value);\n            lines = (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndef)(label) ? [] : utils.toTextLines(label);\n            if (lines.length) {\n                model = me._modelize(display, lines, config, context);\n                rects = boundingRects(model);\n            }\n        }\n        me._model = model;\n        me._rects = rects;\n    },\n    geometry: function() {\n        return this._rects ? this._rects.frame : {};\n    },\n    rotation: function() {\n        return this._model ? this._model.rotation : 0;\n    },\n    visible: function() {\n        return this._model && this._model.opacity;\n    },\n    model: function() {\n        return this._model;\n    },\n    draw: function(chart, center) {\n        var me = this;\n        var ctx = chart.ctx;\n        var model = me._model;\n        var rects = me._rects;\n        var area;\n        if (!this.visible()) {\n            return;\n        }\n        ctx.save();\n        if (model.clip) {\n            area = model.area;\n            ctx.beginPath();\n            ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);\n            ctx.clip();\n        }\n        ctx.globalAlpha = utils.bound(0, model.opacity, 1);\n        ctx.translate(rasterize(center.x), rasterize(center.y));\n        ctx.rotate(model.rotation);\n        drawFrame(ctx, rects.frame, model);\n        drawText(ctx, model.lines, rects.text, model);\n        ctx.restore();\n    }\n});\nvar MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991; // eslint-disable-line es/no-number-minsafeinteger\nvar MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991; // eslint-disable-line es/no-number-maxsafeinteger\nfunction rotated(point, center, angle) {\n    var cos = Math.cos(angle);\n    var sin = Math.sin(angle);\n    var cx = center.x;\n    var cy = center.y;\n    return {\n        x: cx + cos * (point.x - cx) - sin * (point.y - cy),\n        y: cy + sin * (point.x - cx) + cos * (point.y - cy)\n    };\n}\nfunction projected(points, axis) {\n    var min = MAX_INTEGER;\n    var max = MIN_INTEGER;\n    var origin = axis.origin;\n    var i, pt, vx, vy, dp;\n    for(i = 0; i < points.length; ++i){\n        pt = points[i];\n        vx = pt.x - origin.x;\n        vy = pt.y - origin.y;\n        dp = axis.vx * vx + axis.vy * vy;\n        min = Math.min(min, dp);\n        max = Math.max(max, dp);\n    }\n    return {\n        min: min,\n        max: max\n    };\n}\nfunction toAxis(p0, p1) {\n    var vx = p1.x - p0.x;\n    var vy = p1.y - p0.y;\n    var ln = Math.sqrt(vx * vx + vy * vy);\n    return {\n        vx: (p1.x - p0.x) / ln,\n        vy: (p1.y - p0.y) / ln,\n        origin: p0,\n        ln: ln\n    };\n}\nvar HitBox = function() {\n    this._rotation = 0;\n    this._rect = {\n        x: 0,\n        y: 0,\n        w: 0,\n        h: 0\n    };\n};\n(0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.merge)(HitBox.prototype, {\n    center: function() {\n        var r = this._rect;\n        return {\n            x: r.x + r.w / 2,\n            y: r.y + r.h / 2\n        };\n    },\n    update: function(center, rect, rotation) {\n        this._rotation = rotation;\n        this._rect = {\n            x: rect.x + center.x,\n            y: rect.y + center.y,\n            w: rect.w,\n            h: rect.h\n        };\n    },\n    contains: function(point) {\n        var me = this;\n        var margin = 1;\n        var rect = me._rect;\n        point = rotated(point, me.center(), -me._rotation);\n        return !(point.x < rect.x - margin || point.y < rect.y - margin || point.x > rect.x + rect.w + margin * 2 || point.y > rect.y + rect.h + margin * 2);\n    },\n    // Separating Axis Theorem\n    // https://gamedevelopment.tutsplus.com/tutorials/collision-detection-using-the-separating-axis-theorem--gamedev-169\n    intersects: function(other) {\n        var r0 = this._points();\n        var r1 = other._points();\n        var axes = [\n            toAxis(r0[0], r0[1]),\n            toAxis(r0[0], r0[3])\n        ];\n        var i, pr0, pr1;\n        if (this._rotation !== other._rotation) {\n            // Only separate with r1 axis if the rotation is different,\n            // else it's enough to separate r0 and r1 with r0 axis only!\n            axes.push(toAxis(r1[0], r1[1]), toAxis(r1[0], r1[3]));\n        }\n        for(i = 0; i < axes.length; ++i){\n            pr0 = projected(r0, axes[i]);\n            pr1 = projected(r1, axes[i]);\n            if (pr0.max < pr1.min || pr1.max < pr0.min) {\n                return false;\n            }\n        }\n        return true;\n    },\n    /**\n   * @private\n   */ _points: function() {\n        var me = this;\n        var rect = me._rect;\n        var angle = me._rotation;\n        var center = me.center();\n        return [\n            rotated({\n                x: rect.x,\n                y: rect.y\n            }, center, angle),\n            rotated({\n                x: rect.x + rect.w,\n                y: rect.y\n            }, center, angle),\n            rotated({\n                x: rect.x + rect.w,\n                y: rect.y + rect.h\n            }, center, angle),\n            rotated({\n                x: rect.x,\n                y: rect.y + rect.h\n            }, center, angle)\n        ];\n    }\n});\nfunction coordinates(el, model, geometry) {\n    var point = model.positioner(el, model);\n    var vx = point.vx;\n    var vy = point.vy;\n    if (!vx && !vy) {\n        // if aligned center, we don't want to offset the center point\n        return {\n            x: point.x,\n            y: point.y\n        };\n    }\n    var w = geometry.w;\n    var h = geometry.h;\n    // take in account the label rotation\n    var rotation = model.rotation;\n    var dx = Math.abs(w / 2 * Math.cos(rotation)) + Math.abs(h / 2 * Math.sin(rotation));\n    var dy = Math.abs(w / 2 * Math.sin(rotation)) + Math.abs(h / 2 * Math.cos(rotation));\n    // scale the unit vector (vx, vy) to get at least dx or dy equal to\n    // w or h respectively (else we would calculate the distance to the\n    // ellipse inscribed in the bounding rect)\n    var vs = 1 / Math.max(Math.abs(vx), Math.abs(vy));\n    dx *= vx * vs;\n    dy *= vy * vs;\n    // finally, include the explicit offset\n    dx += model.offset * vx;\n    dy += model.offset * vy;\n    return {\n        x: point.x + dx,\n        y: point.y + dy\n    };\n}\nfunction collide(labels, collider) {\n    var i, j, s0, s1;\n    // IMPORTANT Iterate in the reverse order since items at the end of the\n    // list have an higher weight/priority and thus should be less impacted\n    // by the overlapping strategy.\n    for(i = labels.length - 1; i >= 0; --i){\n        s0 = labels[i].$layout;\n        for(j = i - 1; j >= 0 && s0._visible; --j){\n            s1 = labels[j].$layout;\n            if (s1._visible && s0._box.intersects(s1._box)) {\n                collider(s0, s1);\n            }\n        }\n    }\n    return labels;\n}\nfunction compute(labels) {\n    var i, ilen, label, state, geometry, center, proxy;\n    // Initialize labels for overlap detection\n    for(i = 0, ilen = labels.length; i < ilen; ++i){\n        label = labels[i];\n        state = label.$layout;\n        if (state._visible) {\n            // Chart.js 3 removed el._model in favor of getProps(), making harder to\n            // abstract reading values in positioners. Also, using string arrays to\n            // read values (i.e. var {a,b,c} = el.getProps([\"a\",\"b\",\"c\"])) would make\n            // positioners inefficient in the normal case (i.e. not the final values)\n            // and the code a bit ugly, so let's use a Proxy instead.\n            proxy = new Proxy(label._el, {\n                get: (el, p)=>el.getProps([\n                        p\n                    ], true)[p]\n            });\n            geometry = label.geometry();\n            center = coordinates(proxy, label.model(), geometry);\n            state._box.update(center, geometry, label.rotation());\n        }\n    }\n    // Auto hide overlapping labels\n    return collide(labels, function(s0, s1) {\n        var h0 = s0._hidable;\n        var h1 = s1._hidable;\n        if (h0 && h1 || h1) {\n            s1._visible = false;\n        } else if (h0) {\n            s0._visible = false;\n        }\n    });\n}\nvar layout = {\n    prepare: function(datasets) {\n        var labels = [];\n        var i, j, ilen, jlen, label;\n        for(i = 0, ilen = datasets.length; i < ilen; ++i){\n            for(j = 0, jlen = datasets[i].length; j < jlen; ++j){\n                label = datasets[i][j];\n                labels.push(label);\n                label.$layout = {\n                    _box: new HitBox(),\n                    _hidable: false,\n                    _visible: true,\n                    _set: i,\n                    _idx: label._index\n                };\n            }\n        }\n        // TODO New `z` option: labels with a higher z-index are drawn\n        // of top of the ones with a lower index. Lowest z-index labels\n        // are also discarded first when hiding overlapping labels.\n        labels.sort(function(a, b) {\n            var sa = a.$layout;\n            var sb = b.$layout;\n            return sa._idx === sb._idx ? sb._set - sa._set : sb._idx - sa._idx;\n        });\n        this.update(labels);\n        return labels;\n    },\n    update: function(labels) {\n        var dirty = false;\n        var i, ilen, label, model, state;\n        for(i = 0, ilen = labels.length; i < ilen; ++i){\n            label = labels[i];\n            model = label.model();\n            state = label.$layout;\n            state._hidable = model && model.display === \"auto\";\n            state._visible = label.visible();\n            dirty |= state._hidable;\n        }\n        if (dirty) {\n            compute(labels);\n        }\n    },\n    lookup: function(labels, point) {\n        var i, state;\n        // IMPORTANT Iterate in the reverse order since items at the end of\n        // the list have an higher z-index, thus should be picked first.\n        for(i = labels.length - 1; i >= 0; --i){\n            state = labels[i].$layout;\n            if (state && state._visible && state._box.contains(point)) {\n                return labels[i];\n            }\n        }\n        return null;\n    },\n    draw: function(chart, labels) {\n        var i, ilen, label, state, geometry, center;\n        for(i = 0, ilen = labels.length; i < ilen; ++i){\n            label = labels[i];\n            state = label.$layout;\n            if (state._visible) {\n                geometry = label.geometry();\n                center = coordinates(label._el, label.model(), geometry);\n                state._box.update(center, geometry, label.rotation());\n                label.draw(chart, center);\n            }\n        }\n    }\n};\nvar formatter = function(value) {\n    if ((0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndef)(value)) {\n        return null;\n    }\n    var label = value;\n    var keys, klen, k;\n    if ((0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.isObject)(value)) {\n        if (!(0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndef)(value.label)) {\n            label = value.label;\n        } else if (!(0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndef)(value.r)) {\n            label = value.r;\n        } else {\n            label = \"\";\n            keys = Object.keys(value);\n            for(k = 0, klen = keys.length; k < klen; ++k){\n                label += (k !== 0 ? \", \" : \"\") + keys[k] + \": \" + value[keys[k]];\n            }\n        }\n    }\n    return \"\" + label;\n};\n/**\n * IMPORTANT: make sure to also update tests and TypeScript definition\n * files (`/test/specs/defaults.spec.js` and `/types/options.d.ts`)\n */ var defaults = {\n    align: \"center\",\n    anchor: \"center\",\n    backgroundColor: null,\n    borderColor: null,\n    borderRadius: 0,\n    borderWidth: 0,\n    clamp: false,\n    clip: false,\n    color: undefined,\n    display: true,\n    font: {\n        family: undefined,\n        lineHeight: 1.2,\n        size: undefined,\n        style: undefined,\n        weight: null\n    },\n    formatter: formatter,\n    labels: undefined,\n    listeners: {},\n    offset: 4,\n    opacity: 1,\n    padding: {\n        top: 4,\n        right: 4,\n        bottom: 4,\n        left: 4\n    },\n    rotation: 0,\n    textAlign: \"start\",\n    textStrokeColor: undefined,\n    textStrokeWidth: 0,\n    textShadowBlur: 0,\n    textShadowColor: undefined\n};\n/**\n * @see https://github.com/chartjs/Chart.js/issues/4176\n */ var EXPANDO_KEY = \"$datalabels\";\nvar DEFAULT_KEY = \"$default\";\nfunction configure(dataset, options) {\n    var override = dataset.datalabels;\n    var listeners = {};\n    var configs = [];\n    var labels, keys;\n    if (override === false) {\n        return null;\n    }\n    if (override === true) {\n        override = {};\n    }\n    options = (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.merge)({}, [\n        options,\n        override\n    ]);\n    labels = options.labels || {};\n    keys = Object.keys(labels);\n    delete options.labels;\n    if (keys.length) {\n        keys.forEach(function(key) {\n            if (labels[key]) {\n                configs.push((0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.merge)({}, [\n                    options,\n                    labels[key],\n                    {\n                        _key: key\n                    }\n                ]));\n            }\n        });\n    } else {\n        // Default label if no \"named\" label defined.\n        configs.push(options);\n    }\n    // listeners: {<event-type>: {<label-key>: <fn>}}\n    listeners = configs.reduce(function(target, config) {\n        (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.each)(config.listeners || {}, function(fn, event) {\n            target[event] = target[event] || {};\n            target[event][config._key || DEFAULT_KEY] = fn;\n        });\n        delete config.listeners;\n        return target;\n    }, {});\n    return {\n        labels: configs,\n        listeners: listeners\n    };\n}\nfunction dispatchEvent(chart, listeners, label, event) {\n    if (!listeners) {\n        return;\n    }\n    var context = label.$context;\n    var groups = label.$groups;\n    var callback$1;\n    if (!listeners[groups._set]) {\n        return;\n    }\n    callback$1 = listeners[groups._set][groups._key];\n    if (!callback$1) {\n        return;\n    }\n    if ((0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.callback)(callback$1, [\n        context,\n        event\n    ]) === true) {\n        // Users are allowed to tweak the given context by injecting values that can be\n        // used in scriptable options to display labels differently based on the current\n        // event (e.g. highlight an hovered label). That's why we update the label with\n        // the output context and schedule a new chart render by setting it dirty.\n        chart[EXPANDO_KEY]._dirty = true;\n        label.update(context);\n    }\n}\nfunction dispatchMoveEvents(chart, listeners, previous, label, event) {\n    var enter, leave;\n    if (!previous && !label) {\n        return;\n    }\n    if (!previous) {\n        enter = true;\n    } else if (!label) {\n        leave = true;\n    } else if (previous !== label) {\n        leave = enter = true;\n    }\n    if (leave) {\n        dispatchEvent(chart, listeners.leave, previous, event);\n    }\n    if (enter) {\n        dispatchEvent(chart, listeners.enter, label, event);\n    }\n}\nfunction handleMoveEvents(chart, event) {\n    var expando = chart[EXPANDO_KEY];\n    var listeners = expando._listeners;\n    var previous, label;\n    if (!listeners.enter && !listeners.leave) {\n        return;\n    }\n    if (event.type === \"mousemove\") {\n        label = layout.lookup(expando._labels, event);\n    } else if (event.type !== \"mouseout\") {\n        return;\n    }\n    previous = expando._hovered;\n    expando._hovered = label;\n    dispatchMoveEvents(chart, listeners, previous, label, event);\n}\nfunction handleClickEvents(chart, event) {\n    var expando = chart[EXPANDO_KEY];\n    var handlers = expando._listeners.click;\n    var label = handlers && layout.lookup(expando._labels, event);\n    if (label) {\n        dispatchEvent(chart, handlers, label, event);\n    }\n}\nvar plugin = {\n    id: \"datalabels\",\n    defaults: defaults,\n    beforeInit: function(chart) {\n        chart[EXPANDO_KEY] = {\n            _actives: []\n        };\n    },\n    beforeUpdate: function(chart) {\n        var expando = chart[EXPANDO_KEY];\n        expando._listened = false;\n        expando._listeners = {}; // {<event-type>: {<dataset-index>: {<label-key>: <fn>}}}\n        expando._datasets = []; // per dataset labels: [Label[]]\n        expando._labels = []; // layouted labels: Label[]\n    },\n    afterDatasetUpdate: function(chart, args, options) {\n        var datasetIndex = args.index;\n        var expando = chart[EXPANDO_KEY];\n        var labels = expando._datasets[datasetIndex] = [];\n        var visible = chart.isDatasetVisible(datasetIndex);\n        var dataset = chart.data.datasets[datasetIndex];\n        var config = configure(dataset, options);\n        var elements = args.meta.data || [];\n        var ctx = chart.ctx;\n        var i, j, ilen, jlen, cfg, key, el, label;\n        ctx.save();\n        for(i = 0, ilen = elements.length; i < ilen; ++i){\n            el = elements[i];\n            el[EXPANDO_KEY] = [];\n            if (visible && el && chart.getDataVisibility(i) && !el.skip) {\n                for(j = 0, jlen = config.labels.length; j < jlen; ++j){\n                    cfg = config.labels[j];\n                    key = cfg._key;\n                    label = new Label(cfg, ctx, el, i);\n                    label.$groups = {\n                        _set: datasetIndex,\n                        _key: key || DEFAULT_KEY\n                    };\n                    label.$context = {\n                        active: false,\n                        chart: chart,\n                        dataIndex: i,\n                        dataset: dataset,\n                        datasetIndex: datasetIndex\n                    };\n                    label.update(label.$context);\n                    el[EXPANDO_KEY].push(label);\n                    labels.push(label);\n                }\n            }\n        }\n        ctx.restore();\n        // Store listeners at the chart level and per event type to optimize\n        // cases where no listeners are registered for a specific event.\n        (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.merge)(expando._listeners, config.listeners, {\n            merger: function(event, target, source) {\n                target[event] = target[event] || {};\n                target[event][args.index] = source[event];\n                expando._listened = true;\n            }\n        });\n    },\n    afterUpdate: function(chart) {\n        chart[EXPANDO_KEY]._labels = layout.prepare(chart[EXPANDO_KEY]._datasets);\n    },\n    // Draw labels on top of all dataset elements\n    // https://github.com/chartjs/chartjs-plugin-datalabels/issues/29\n    // https://github.com/chartjs/chartjs-plugin-datalabels/issues/32\n    afterDatasetsDraw: function(chart) {\n        layout.draw(chart, chart[EXPANDO_KEY]._labels);\n    },\n    beforeEvent: function(chart, args) {\n        // If there is no listener registered for this chart, `listened` will be false,\n        // meaning we can immediately ignore the incoming event and avoid useless extra\n        // computation for users who don't implement label interactions.\n        if (chart[EXPANDO_KEY]._listened) {\n            var event = args.event;\n            switch(event.type){\n                case \"mousemove\":\n                case \"mouseout\":\n                    handleMoveEvents(chart, event);\n                    break;\n                case \"click\":\n                    handleClickEvents(chart, event);\n                    break;\n            }\n        }\n    },\n    afterEvent: function(chart) {\n        var expando = chart[EXPANDO_KEY];\n        var previous = expando._actives;\n        var actives = expando._actives = chart.getActiveElements();\n        var updates = utils.arrayDiff(previous, actives);\n        var i, ilen, j, jlen, update, label, labels;\n        for(i = 0, ilen = updates.length; i < ilen; ++i){\n            update = updates[i];\n            if (update[1]) {\n                labels = update[0].element[EXPANDO_KEY] || [];\n                for(j = 0, jlen = labels.length; j < jlen; ++j){\n                    label = labels[j];\n                    label.$context.active = update[1] === 1;\n                    label.update(label.$context);\n                }\n            }\n        }\n        if (expando._dirty || updates.length) {\n            layout.update(expando._labels);\n            chart.render();\n        }\n        delete expando._dirty;\n    }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hhcnRqcy1wbHVnaW4tZGF0YWxhYmVscy9kaXN0L2NoYXJ0anMtcGx1Z2luLWRhdGFsYWJlbHMuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7Ozs7Q0FLQyxHQUM2SDtBQUN0QztBQUV4RixJQUFJYyxtQkFBb0I7SUFDdEIsSUFBSSxLQUFrQixFQUFhLGVBWWxDO0lBRUQsT0FBTztBQUNUO0FBRUEsSUFBSUssUUFBUTtJQUNWLCtDQUErQztJQUMvQ0MsYUFBYSxTQUFTQyxNQUFNO1FBQzFCLElBQUlDLFFBQVEsRUFBRTtRQUNkLElBQUlDO1FBRUpGLFNBQVMsRUFBRSxDQUFDRyxNQUFNLENBQUNIO1FBQ25CLE1BQU9BLE9BQU9JLE1BQU0sQ0FBRTtZQUNwQkYsUUFBUUYsT0FBT0ssR0FBRztZQUNsQixJQUFJLE9BQU9ILFVBQVUsVUFBVTtnQkFDN0JELE1BQU1LLE9BQU8sQ0FBQ0MsS0FBSyxDQUFDTixPQUFPQyxNQUFNTSxLQUFLLENBQUM7WUFDekMsT0FBTyxJQUFJQyxNQUFNQyxPQUFPLENBQUNSLFFBQVE7Z0JBQy9CRixPQUFPVyxJQUFJLENBQUNKLEtBQUssQ0FBQ1AsUUFBUUU7WUFDNUIsT0FBTyxJQUFJLENBQUN2QiwrREFBYUEsQ0FBQ3FCLFNBQVM7Z0JBQ2pDQyxNQUFNSyxPQUFPLENBQUMsS0FBS0o7WUFDckI7UUFDRjtRQUVBLE9BQU9EO0lBQ1Q7SUFFQSxtREFBbUQ7SUFDbkQsNERBQTREO0lBQzVEVyxVQUFVLFNBQVNDLEdBQUcsRUFBRVosS0FBSyxFQUFFYSxJQUFJO1FBQ2pDLElBQUlDLFFBQVEsRUFBRSxDQUFDWixNQUFNLENBQUNGO1FBQ3RCLElBQUllLE9BQU9ELE1BQU1YLE1BQU07UUFDdkIsSUFBSWEsT0FBT0osSUFBSUMsSUFBSTtRQUNuQixJQUFJSSxRQUFRO1FBQ1osSUFBSUM7UUFFSk4sSUFBSUMsSUFBSSxHQUFHQSxLQUFLTSxNQUFNO1FBRXRCLElBQUtELElBQUksR0FBR0Es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TUFBTSxDQUFDak0sRUFBRTtvQkFDakJzSixNQUFNK0YsUUFBUSxDQUFDZ0MsTUFBTSxHQUFJakksTUFBTSxDQUFDLEVBQUUsS0FBSztvQkFDdkNFLE1BQU1GLE1BQU0sQ0FBQ0UsTUFBTStGLFFBQVE7Z0JBQzdCO1lBQ0Y7UUFDRjtRQUVBLElBQUlVLFFBQVFOLE1BQU0sSUFBSTFQLFFBQVE3QixNQUFNLEVBQUU7WUFDcENnUCxPQUFPOUQsTUFBTSxDQUFDMkcsUUFBUUcsT0FBTztZQUM3QjlLLE1BQU00TSxNQUFNO1FBQ2Q7UUFFQSxPQUFPakMsUUFBUU4sTUFBTTtJQUN2QjtBQUNGO0FBRTZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2ltcy1hbmFseXRpY3MtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL2NoYXJ0anMtcGx1Z2luLWRhdGFsYWJlbHMvZGlzdC9jaGFydGpzLXBsdWdpbi1kYXRhbGFiZWxzLmVzbS5qcz8wZDBmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogY2hhcnRqcy1wbHVnaW4tZGF0YWxhYmVscyB2Mi4yLjBcbiAqIGh0dHBzOi8vY2hhcnRqcy1wbHVnaW4tZGF0YWxhYmVscy5uZXRsaWZ5LmFwcFxuICogKGMpIDIwMTctMjAyMiBjaGFydGpzLXBsdWdpbi1kYXRhbGFiZWxzIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmltcG9ydCB7IGlzTnVsbE9yVW5kZWYsIG1lcmdlLCB0b0ZvbnQsIHJlc29sdmUsIHRvUGFkZGluZywgdmFsdWVPckRlZmF1bHQsIGNhbGxiYWNrLCBpc09iamVjdCwgZWFjaCB9IGZyb20gJ2NoYXJ0LmpzL2hlbHBlcnMnO1xuaW1wb3J0IHsgZGVmYXVsdHMgYXMgZGVmYXVsdHMkMSwgQXJjRWxlbWVudCwgUG9pbnRFbGVtZW50LCBCYXJFbGVtZW50IH0gZnJvbSAnY2hhcnQuanMnO1xuXG52YXIgZGV2aWNlUGl4ZWxSYXRpbyA9IChmdW5jdGlvbigpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKSB7XG4gICAgICByZXR1cm4gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gICAgfVxuXG4gICAgLy8gZGV2aWNlUGl4ZWxSYXRpbyBpcyB1bmRlZmluZWQgb24gSUUxMFxuICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMDIwNDE4MC84ODM3ODg3XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvY2hhcnRqcy1wbHVnaW4tZGF0YWxhYmVscy9pc3N1ZXMvODVcbiAgICB2YXIgc2NyZWVuID0gd2luZG93LnNjcmVlbjtcbiAgICBpZiAoc2NyZWVuKSB7XG4gICAgICByZXR1cm4gKHNjcmVlbi5kZXZpY2VYRFBJIHx8IDEpIC8gKHNjcmVlbi5sb2dpY2FsWERQSSB8fCAxKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMTtcbn0oKSk7XG5cbnZhciB1dGlscyA9IHtcbiAgLy8gQHRvZG8gbW92ZSB0aGlzIGluIENoYXJ0LmhlbHBlcnMudG9UZXh0TGluZXNcbiAgdG9UZXh0TGluZXM6IGZ1bmN0aW9uKGlucHV0cykge1xuICAgIHZhciBsaW5lcyA9IFtdO1xuICAgIHZhciBpbnB1dDtcblxuICAgIGlucHV0cyA9IFtdLmNvbmNhdChpbnB1dHMpO1xuICAgIHdoaWxlIChpbnB1dHMubGVuZ3RoKSB7XG4gICAgICBpbnB1dCA9IGlucHV0cy5wb3AoKTtcbiAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGxpbmVzLnVuc2hpZnQuYXBwbHkobGluZXMsIGlucHV0LnNwbGl0KCdcXG4nKSk7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgIGlucHV0cy5wdXNoLmFwcGx5KGlucHV0cywgaW5wdXQpO1xuICAgICAgfSBlbHNlIGlmICghaXNOdWxsT3JVbmRlZihpbnB1dHMpKSB7XG4gICAgICAgIGxpbmVzLnVuc2hpZnQoJycgKyBpbnB1dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpbmVzO1xuICB9LFxuXG4gIC8vIEB0b2RvIG1vdmUgdGhpcyBpbiBDaGFydC5oZWxwZXJzLmNhbnZhcy50ZXh0U2l6ZVxuICAvLyBAdG9kbyBjYWNoZSBjYWxscyBvZiBtZWFzdXJlVGV4dCBpZiBmb250IGRvZXNuJ3QgY2hhbmdlPyFcbiAgdGV4dFNpemU6IGZ1bmN0aW9uKGN0eCwgbGluZXMsIGZvbnQpIHtcbiAgICB2YXIgaXRlbXMgPSBbXS5jb25jYXQobGluZXMpO1xuICAgIHZhciBpbGVuID0gaXRlbXMubGVuZ3RoO1xuICAgIHZhciBwcmV2ID0gY3R4LmZvbnQ7XG4gICAgdmFyIHdpZHRoID0gMDtcbiAgICB2YXIgaTtcblxuICAgIGN0eC5mb250ID0gZm9udC5zdHJpbmc7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB3aWR0aCA9IE1hdGgubWF4KGN0eC5tZWFzdXJlVGV4dChpdGVtc1tpXSkud2lkdGgsIHdpZHRoKTtcbiAgICB9XG5cbiAgICBjdHguZm9udCA9IHByZXY7XG5cbiAgICByZXR1cm4ge1xuICAgICAgaGVpZ2h0OiBpbGVuICogZm9udC5saW5lSGVpZ2h0LFxuICAgICAgd2lkdGg6IHdpZHRoXG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB2YWx1ZSBib3VuZGVkIGJ5IG1pbiBhbmQgbWF4LiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gbWF4KG1pbiwgbWluKHZhbHVlLCBtYXgpKS5cbiAgICogQHRvZG8gbW92ZSB0aGlzIG1ldGhvZCBpbiBDaGFydC5oZWxwZXJzLmJvdW5kXG4gICAqIGh0dHBzOi8vZG9jLnF0LmlvL3F0LTUvcXRnbG9iYWwuaHRtbCNxQm91bmRcbiAgICovXG4gIGJvdW5kOiBmdW5jdGlvbihtaW4sIHZhbHVlLCBtYXgpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbih2YWx1ZSwgbWF4KSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgb2YgcGFpciBbdmFsdWUsIHN0YXRlXSB3aGVyZSBzdGF0ZSBpczpcbiAgICogKiAtMTogdmFsdWUgaXMgb25seSBpbiBhMCAocmVtb3ZlZClcbiAgICogKiAgMTogdmFsdWUgaXMgb25seSBpbiBhMSAoYWRkZWQpXG4gICAqL1xuICBhcnJheURpZmY6IGZ1bmN0aW9uKGEwLCBhMSkge1xuICAgIHZhciBwcmV2ID0gYTAuc2xpY2UoKTtcbiAgICB2YXIgdXBkYXRlcyA9IFtdO1xuICAgIHZhciBpLCBqLCBpbGVuLCB2O1xuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGExLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdiA9IGExW2ldO1xuICAgICAgaiA9IHByZXYuaW5kZXhPZih2KTtcblxuICAgICAgaWYgKGogPT09IC0xKSB7XG4gICAgICAgIHVwZGF0ZXMucHVzaChbdiwgMV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJldi5zcGxpY2UoaiwgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHByZXYubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB1cGRhdGVzLnB1c2goW3ByZXZbaV0sIC0xXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVwZGF0ZXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL2NoYXJ0anMtcGx1Z2luLWRhdGFsYWJlbHMvaXNzdWVzLzcwXG4gICAqL1xuICByYXN0ZXJpemU6IGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCh2ICogZGV2aWNlUGl4ZWxSYXRpbykgLyBkZXZpY2VQaXhlbFJhdGlvO1xuICB9XG59O1xuXG5mdW5jdGlvbiBvcmllbnQocG9pbnQsIG9yaWdpbikge1xuICB2YXIgeDAgPSBvcmlnaW4ueDtcbiAgdmFyIHkwID0gb3JpZ2luLnk7XG5cbiAgaWYgKHgwID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHt4OiAwLCB5OiAtMX07XG4gIH1cbiAgaWYgKHkwID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHt4OiAxLCB5OiAwfTtcbiAgfVxuXG4gIHZhciBkeCA9IHBvaW50LnggLSB4MDtcbiAgdmFyIGR5ID0gcG9pbnQueSAtIHkwO1xuICB2YXIgbG4gPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gIHJldHVybiB7XG4gICAgeDogbG4gPyBkeCAvIGxuIDogMCxcbiAgICB5OiBsbiA/IGR5IC8gbG4gOiAtMVxuICB9O1xufVxuXG5mdW5jdGlvbiBhbGlnbmVkKHgsIHksIHZ4LCB2eSwgYWxpZ24pIHtcbiAgc3dpdGNoIChhbGlnbikge1xuICBjYXNlICdjZW50ZXInOlxuICAgIHZ4ID0gdnkgPSAwO1xuICAgIGJyZWFrO1xuICBjYXNlICdib3R0b20nOlxuICAgIHZ4ID0gMDtcbiAgICB2eSA9IDE7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ3JpZ2h0JzpcbiAgICB2eCA9IDE7XG4gICAgdnkgPSAwO1xuICAgIGJyZWFrO1xuICBjYXNlICdsZWZ0JzpcbiAgICB2eCA9IC0xO1xuICAgIHZ5ID0gMDtcbiAgICBicmVhaztcbiAgY2FzZSAndG9wJzpcbiAgICB2eCA9IDA7XG4gICAgdnkgPSAtMTtcbiAgICBicmVhaztcbiAgY2FzZSAnc3RhcnQnOlxuICAgIHZ4ID0gLXZ4O1xuICAgIHZ5ID0gLXZ5O1xuICAgIGJyZWFrO1xuICBjYXNlICdlbmQnOlxuICAgIC8vIGtlZXAgbmF0dXJhbCBvcmllbnRhdGlvblxuICAgIGJyZWFrO1xuICBkZWZhdWx0OlxuICAgIC8vIGNsb2Nrd2lzZSByb3RhdGlvbiAoaW4gZGVncmVlKVxuICAgIGFsaWduICo9IChNYXRoLlBJIC8gMTgwKTtcbiAgICB2eCA9IE1hdGguY29zKGFsaWduKTtcbiAgICB2eSA9IE1hdGguc2luKGFsaWduKTtcbiAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDogeCxcbiAgICB5OiB5LFxuICAgIHZ4OiB2eCxcbiAgICB2eTogdnlcbiAgfTtcbn1cblxuLy8gTGluZSBjbGlwcGluZyAoQ29oZW7igJNTdXRoZXJsYW5kIGFsZ29yaXRobSlcbi8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvaGVu4oCTU3V0aGVybGFuZF9hbGdvcml0aG1cblxudmFyIFJfSU5TSURFID0gMDtcbnZhciBSX0xFRlQgPSAxO1xudmFyIFJfUklHSFQgPSAyO1xudmFyIFJfQk9UVE9NID0gNDtcbnZhciBSX1RPUCA9IDg7XG5cbmZ1bmN0aW9uIHJlZ2lvbih4LCB5LCByZWN0KSB7XG4gIHZhciByZXMgPSBSX0lOU0lERTtcblxuICBpZiAoeCA8IHJlY3QubGVmdCkge1xuICAgIHJlcyB8PSBSX0xFRlQ7XG4gIH0gZWxzZSBpZiAoeCA+IHJlY3QucmlnaHQpIHtcbiAgICByZXMgfD0gUl9SSUdIVDtcbiAgfVxuICBpZiAoeSA8IHJlY3QudG9wKSB7XG4gICAgcmVzIHw9IFJfVE9QO1xuICB9IGVsc2UgaWYgKHkgPiByZWN0LmJvdHRvbSkge1xuICAgIHJlcyB8PSBSX0JPVFRPTTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIGNsaXBwZWQoc2VnbWVudCwgYXJlYSkge1xuICB2YXIgeDAgPSBzZWdtZW50LngwO1xuICB2YXIgeTAgPSBzZWdtZW50LnkwO1xuICB2YXIgeDEgPSBzZWdtZW50LngxO1xuICB2YXIgeTEgPSBzZWdtZW50LnkxO1xuICB2YXIgcjAgPSByZWdpb24oeDAsIHkwLCBhcmVhKTtcbiAgdmFyIHIxID0gcmVnaW9uKHgxLCB5MSwgYXJlYSk7XG4gIHZhciByLCB4LCB5O1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAoIShyMCB8IHIxKSB8fCAocjAgJiByMSkpIHtcbiAgICAgIC8vIGJvdGggcG9pbnRzIGluc2lkZSBvciBvbiB0aGUgc2FtZSBzaWRlOiBubyBjbGlwcGluZ1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gYXQgbGVhc3Qgb25lIHBvaW50IGlzIG91dHNpZGVcbiAgICByID0gcjAgfHwgcjE7XG5cbiAgICBpZiAociAmIFJfVE9QKSB7XG4gICAgICB4ID0geDAgKyAoeDEgLSB4MCkgKiAoYXJlYS50b3AgLSB5MCkgLyAoeTEgLSB5MCk7XG4gICAgICB5ID0gYXJlYS50b3A7XG4gICAgfSBlbHNlIGlmIChyICYgUl9CT1RUT00pIHtcbiAgICAgIHggPSB4MCArICh4MSAtIHgwKSAqIChhcmVhLmJvdHRvbSAtIHkwKSAvICh5MSAtIHkwKTtcbiAgICAgIHkgPSBhcmVhLmJvdHRvbTtcbiAgICB9IGVsc2UgaWYgKHIgJiBSX1JJR0hUKSB7XG4gICAgICB5ID0geTAgKyAoeTEgLSB5MCkgKiAoYXJlYS5yaWdodCAtIHgwKSAvICh4MSAtIHgwKTtcbiAgICAgIHggPSBhcmVhLnJpZ2h0O1xuICAgIH0gZWxzZSBpZiAociAmIFJfTEVGVCkge1xuICAgICAgeSA9IHkwICsgKHkxIC0geTApICogKGFyZWEubGVmdCAtIHgwKSAvICh4MSAtIHgwKTtcbiAgICAgIHggPSBhcmVhLmxlZnQ7XG4gICAgfVxuXG4gICAgaWYgKHIgPT09IHIwKSB7XG4gICAgICB4MCA9IHg7XG4gICAgICB5MCA9IHk7XG4gICAgICByMCA9IHJlZ2lvbih4MCwgeTAsIGFyZWEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB4MSA9IHg7XG4gICAgICB5MSA9IHk7XG4gICAgICByMSA9IHJlZ2lvbih4MSwgeTEsIGFyZWEpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDA6IHgwLFxuICAgIHgxOiB4MSxcbiAgICB5MDogeTAsXG4gICAgeTE6IHkxXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGUkMShyYW5nZSwgY29uZmlnKSB7XG4gIHZhciBhbmNob3IgPSBjb25maWcuYW5jaG9yO1xuICB2YXIgc2VnbWVudCA9IHJhbmdlO1xuICB2YXIgeCwgeTtcblxuICBpZiAoY29uZmlnLmNsYW1wKSB7XG4gICAgc2VnbWVudCA9IGNsaXBwZWQoc2VnbWVudCwgY29uZmlnLmFyZWEpO1xuICB9XG5cbiAgaWYgKGFuY2hvciA9PT0gJ3N0YXJ0Jykge1xuICAgIHggPSBzZWdtZW50LngwO1xuICAgIHkgPSBzZWdtZW50LnkwO1xuICB9IGVsc2UgaWYgKGFuY2hvciA9PT0gJ2VuZCcpIHtcbiAgICB4ID0gc2VnbWVudC54MTtcbiAgICB5ID0gc2VnbWVudC55MTtcbiAgfSBlbHNlIHtcbiAgICB4ID0gKHNlZ21lbnQueDAgKyBzZWdtZW50LngxKSAvIDI7XG4gICAgeSA9IChzZWdtZW50LnkwICsgc2VnbWVudC55MSkgLyAyO1xuICB9XG5cbiAgcmV0dXJuIGFsaWduZWQoeCwgeSwgcmFuZ2UudngsIHJhbmdlLnZ5LCBjb25maWcuYWxpZ24pO1xufVxuXG52YXIgcG9zaXRpb25lcnMgPSB7XG4gIGFyYzogZnVuY3Rpb24oZWwsIGNvbmZpZykge1xuICAgIHZhciBhbmdsZSA9IChlbC5zdGFydEFuZ2xlICsgZWwuZW5kQW5nbGUpIC8gMjtcbiAgICB2YXIgdnggPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgdmFyIHZ5ID0gTWF0aC5zaW4oYW5nbGUpO1xuICAgIHZhciByMCA9IGVsLmlubmVyUmFkaXVzO1xuICAgIHZhciByMSA9IGVsLm91dGVyUmFkaXVzO1xuXG4gICAgcmV0dXJuIGNvbXB1dGUkMSh7XG4gICAgICB4MDogZWwueCArIHZ4ICogcjAsXG4gICAgICB5MDogZWwueSArIHZ5ICogcjAsXG4gICAgICB4MTogZWwueCArIHZ4ICogcjEsXG4gICAgICB5MTogZWwueSArIHZ5ICogcjEsXG4gICAgICB2eDogdngsXG4gICAgICB2eTogdnlcbiAgICB9LCBjb25maWcpO1xuICB9LFxuXG4gIHBvaW50OiBmdW5jdGlvbihlbCwgY29uZmlnKSB7XG4gICAgdmFyIHYgPSBvcmllbnQoZWwsIGNvbmZpZy5vcmlnaW4pO1xuICAgIHZhciByeCA9IHYueCAqIGVsLm9wdGlvbnMucmFkaXVzO1xuICAgIHZhciByeSA9IHYueSAqIGVsLm9wdGlvbnMucmFkaXVzO1xuXG4gICAgcmV0dXJuIGNvbXB1dGUkMSh7XG4gICAgICB4MDogZWwueCAtIHJ4LFxuICAgICAgeTA6IGVsLnkgLSByeSxcbiAgICAgIHgxOiBlbC54ICsgcngsXG4gICAgICB5MTogZWwueSArIHJ5LFxuICAgICAgdng6IHYueCxcbiAgICAgIHZ5OiB2LnlcbiAgICB9LCBjb25maWcpO1xuICB9LFxuXG4gIGJhcjogZnVuY3Rpb24oZWwsIGNvbmZpZykge1xuICAgIHZhciB2ID0gb3JpZW50KGVsLCBjb25maWcub3JpZ2luKTtcbiAgICB2YXIgeCA9IGVsLng7XG4gICAgdmFyIHkgPSBlbC55O1xuICAgIHZhciBzeCA9IDA7XG4gICAgdmFyIHN5ID0gMDtcblxuICAgIGlmIChlbC5ob3Jpem9udGFsKSB7XG4gICAgICB4ID0gTWF0aC5taW4oZWwueCwgZWwuYmFzZSk7XG4gICAgICBzeCA9IE1hdGguYWJzKGVsLmJhc2UgLSBlbC54KTtcbiAgICB9IGVsc2Uge1xuICAgICAgeSA9IE1hdGgubWluKGVsLnksIGVsLmJhc2UpO1xuICAgICAgc3kgPSBNYXRoLmFicyhlbC5iYXNlIC0gZWwueSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbXB1dGUkMSh7XG4gICAgICB4MDogeCxcbiAgICAgIHkwOiB5ICsgc3ksXG4gICAgICB4MTogeCArIHN4LFxuICAgICAgeTE6IHksXG4gICAgICB2eDogdi54LFxuICAgICAgdnk6IHYueVxuICAgIH0sIGNvbmZpZyk7XG4gIH0sXG5cbiAgZmFsbGJhY2s6IGZ1bmN0aW9uKGVsLCBjb25maWcpIHtcbiAgICB2YXIgdiA9IG9yaWVudChlbCwgY29uZmlnLm9yaWdpbik7XG5cbiAgICByZXR1cm4gY29tcHV0ZSQxKHtcbiAgICAgIHgwOiBlbC54LFxuICAgICAgeTA6IGVsLnksXG4gICAgICB4MTogZWwueCArIChlbC53aWR0aCB8fCAwKSxcbiAgICAgIHkxOiBlbC55ICsgKGVsLmhlaWdodCB8fCAwKSxcbiAgICAgIHZ4OiB2LngsXG4gICAgICB2eTogdi55XG4gICAgfSwgY29uZmlnKTtcbiAgfVxufTtcblxudmFyIHJhc3Rlcml6ZSA9IHV0aWxzLnJhc3Rlcml6ZTtcblxuZnVuY3Rpb24gYm91bmRpbmdSZWN0cyhtb2RlbCkge1xuICB2YXIgYm9yZGVyV2lkdGggPSBtb2RlbC5ib3JkZXJXaWR0aCB8fCAwO1xuICB2YXIgcGFkZGluZyA9IG1vZGVsLnBhZGRpbmc7XG4gIHZhciB0aCA9IG1vZGVsLnNpemUuaGVpZ2h0O1xuICB2YXIgdHcgPSBtb2RlbC5zaXplLndpZHRoO1xuICB2YXIgdHggPSAtdHcgLyAyO1xuICB2YXIgdHkgPSAtdGggLyAyO1xuXG4gIHJldHVybiB7XG4gICAgZnJhbWU6IHtcbiAgICAgIHg6IHR4IC0gcGFkZGluZy5sZWZ0IC0gYm9yZGVyV2lkdGgsXG4gICAgICB5OiB0eSAtIHBhZGRpbmcudG9wIC0gYm9yZGVyV2lkdGgsXG4gICAgICB3OiB0dyArIHBhZGRpbmcud2lkdGggKyBib3JkZXJXaWR0aCAqIDIsXG4gICAgICBoOiB0aCArIHBhZGRpbmcuaGVpZ2h0ICsgYm9yZGVyV2lkdGggKiAyXG4gICAgfSxcbiAgICB0ZXh0OiB7XG4gICAgICB4OiB0eCxcbiAgICAgIHk6IHR5LFxuICAgICAgdzogdHcsXG4gICAgICBoOiB0aFxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0U2NhbGVPcmlnaW4oZWwsIGNvbnRleHQpIHtcbiAgdmFyIHNjYWxlID0gY29udGV4dC5jaGFydC5nZXREYXRhc2V0TWV0YShjb250ZXh0LmRhdGFzZXRJbmRleCkudlNjYWxlO1xuXG4gIGlmICghc2NhbGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChzY2FsZS54Q2VudGVyICE9PSB1bmRlZmluZWQgJiYgc2NhbGUueUNlbnRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHt4OiBzY2FsZS54Q2VudGVyLCB5OiBzY2FsZS55Q2VudGVyfTtcbiAgfVxuXG4gIHZhciBwaXhlbCA9IHNjYWxlLmdldEJhc2VQaXhlbCgpO1xuICByZXR1cm4gZWwuaG9yaXpvbnRhbCA/XG4gICAge3g6IHBpeGVsLCB5OiBudWxsfSA6XG4gICAge3g6IG51bGwsIHk6IHBpeGVsfTtcbn1cblxuZnVuY3Rpb24gZ2V0UG9zaXRpb25lcihlbCkge1xuICBpZiAoZWwgaW5zdGFuY2VvZiBBcmNFbGVtZW50KSB7XG4gICAgcmV0dXJuIHBvc2l0aW9uZXJzLmFyYztcbiAgfVxuICBpZiAoZWwgaW5zdGFuY2VvZiBQb2ludEVsZW1lbnQpIHtcbiAgICByZXR1cm4gcG9zaXRpb25lcnMucG9pbnQ7XG4gIH1cbiAgaWYgKGVsIGluc3RhbmNlb2YgQmFyRWxlbWVudCkge1xuICAgIHJldHVybiBwb3NpdGlvbmVycy5iYXI7XG4gIH1cbiAgcmV0dXJuIHBvc2l0aW9uZXJzLmZhbGxiYWNrO1xufVxuXG5mdW5jdGlvbiBkcmF3Um91bmRlZFJlY3QoY3R4LCB4LCB5LCB3LCBoLCByYWRpdXMpIHtcbiAgdmFyIEhBTEZfUEkgPSBNYXRoLlBJIC8gMjtcblxuICBpZiAocmFkaXVzKSB7XG4gICAgdmFyIHIgPSBNYXRoLm1pbihyYWRpdXMsIGggLyAyLCB3IC8gMik7XG4gICAgdmFyIGxlZnQgPSB4ICsgcjtcbiAgICB2YXIgdG9wID0geSArIHI7XG4gICAgdmFyIHJpZ2h0ID0geCArIHcgLSByO1xuICAgIHZhciBib3R0b20gPSB5ICsgaCAtIHI7XG5cbiAgICBjdHgubW92ZVRvKHgsIHRvcCk7XG4gICAgaWYgKGxlZnQgPCByaWdodCAmJiB0b3AgPCBib3R0b20pIHtcbiAgICAgIGN0eC5hcmMobGVmdCwgdG9wLCByLCAtTWF0aC5QSSwgLUhBTEZfUEkpO1xuICAgICAgY3R4LmFyYyhyaWdodCwgdG9wLCByLCAtSEFMRl9QSSwgMCk7XG4gICAgICBjdHguYXJjKHJpZ2h0LCBib3R0b20sIHIsIDAsIEhBTEZfUEkpO1xuICAgICAgY3R4LmFyYyhsZWZ0LCBib3R0b20sIHIsIEhBTEZfUEksIE1hdGguUEkpO1xuICAgIH0gZWxzZSBpZiAobGVmdCA8IHJpZ2h0KSB7XG4gICAgICBjdHgubW92ZVRvKGxlZnQsIHkpO1xuICAgICAgY3R4LmFyYyhyaWdodCwgdG9wLCByLCAtSEFMRl9QSSwgSEFMRl9QSSk7XG4gICAgICBjdHguYXJjKGxlZnQsIHRvcCwgciwgSEFMRl9QSSwgTWF0aC5QSSArIEhBTEZfUEkpO1xuICAgIH0gZWxzZSBpZiAodG9wIDwgYm90dG9tKSB7XG4gICAgICBjdHguYXJjKGxlZnQsIHRvcCwgciwgLU1hdGguUEksIDApO1xuICAgICAgY3R4LmFyYyhsZWZ0LCBib3R0b20sIHIsIDAsIE1hdGguUEkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHguYXJjKGxlZnQsIHRvcCwgciwgLU1hdGguUEksIE1hdGguUEkpO1xuICAgIH1cbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgY3R4Lm1vdmVUbyh4LCB5KTtcbiAgfSBlbHNlIHtcbiAgICBjdHgucmVjdCh4LCB5LCB3LCBoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkcmF3RnJhbWUoY3R4LCByZWN0LCBtb2RlbCkge1xuICB2YXIgYmdDb2xvciA9IG1vZGVsLmJhY2tncm91bmRDb2xvcjtcbiAgdmFyIGJvcmRlckNvbG9yID0gbW9kZWwuYm9yZGVyQ29sb3I7XG4gIHZhciBib3JkZXJXaWR0aCA9IG1vZGVsLmJvcmRlcldpZHRoO1xuXG4gIGlmICghYmdDb2xvciAmJiAoIWJvcmRlckNvbG9yIHx8ICFib3JkZXJXaWR0aCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgZHJhd1JvdW5kZWRSZWN0KFxuICAgIGN0eCxcbiAgICByYXN0ZXJpemUocmVjdC54KSArIGJvcmRlcldpZHRoIC8gMixcbiAgICByYXN0ZXJpemUocmVjdC55KSArIGJvcmRlcldpZHRoIC8gMixcbiAgICByYXN0ZXJpemUocmVjdC53KSAtIGJvcmRlcldpZHRoLFxuICAgIHJhc3Rlcml6ZShyZWN0LmgpIC0gYm9yZGVyV2lkdGgsXG4gICAgbW9kZWwuYm9yZGVyUmFkaXVzKTtcblxuICBjdHguY2xvc2VQYXRoKCk7XG5cbiAgaWYgKGJnQ29sb3IpIHtcbiAgICBjdHguZmlsbFN0eWxlID0gYmdDb2xvcjtcbiAgICBjdHguZmlsbCgpO1xuICB9XG5cbiAgaWYgKGJvcmRlckNvbG9yICYmIGJvcmRlcldpZHRoKSB7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gYm9yZGVyQ29sb3I7XG4gICAgY3R4LmxpbmVXaWR0aCA9IGJvcmRlcldpZHRoO1xuICAgIGN0eC5saW5lSm9pbiA9ICdtaXRlcic7XG4gICAgY3R4LnN0cm9rZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRleHRHZW9tZXRyeShyZWN0LCBhbGlnbiwgZm9udCkge1xuICB2YXIgaCA9IGZvbnQubGluZUhlaWdodDtcbiAgdmFyIHcgPSByZWN0Lnc7XG4gIHZhciB4ID0gcmVjdC54O1xuICB2YXIgeSA9IHJlY3QueSArIGggLyAyO1xuXG4gIGlmIChhbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICB4ICs9IHcgLyAyO1xuICB9IGVsc2UgaWYgKGFsaWduID09PSAnZW5kJyB8fCBhbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgIHggKz0gdztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgaDogaCxcbiAgICB3OiB3LFxuICAgIHg6IHgsXG4gICAgeTogeVxuICB9O1xufVxuXG5mdW5jdGlvbiBkcmF3VGV4dExpbmUoY3R4LCB0ZXh0LCBjZmcpIHtcbiAgdmFyIHNoYWRvdyA9IGN0eC5zaGFkb3dCbHVyO1xuICB2YXIgc3Ryb2tlZCA9IGNmZy5zdHJva2VkO1xuICB2YXIgeCA9IHJhc3Rlcml6ZShjZmcueCk7XG4gIHZhciB5ID0gcmFzdGVyaXplKGNmZy55KTtcbiAgdmFyIHcgPSByYXN0ZXJpemUoY2ZnLncpO1xuXG4gIGlmIChzdHJva2VkKSB7XG4gICAgY3R4LnN0cm9rZVRleHQodGV4dCwgeCwgeSwgdyk7XG4gIH1cblxuICBpZiAoY2ZnLmZpbGxlZCkge1xuICAgIGlmIChzaGFkb3cgJiYgc3Ryb2tlZCkge1xuICAgICAgLy8gUHJldmVudCBkcmF3aW5nIHNoYWRvdyBvbiBib3RoIHRoZSB0ZXh0IHN0cm9rZSBhbmQgZmlsbCwgc29cbiAgICAgIC8vIGlmIHRoZSB0ZXh0IGlzIHN0cm9rZWQsIHJlbW92ZSB0aGUgc2hhZG93IGZvciB0aGUgdGV4dCBmaWxsLlxuICAgICAgY3R4LnNoYWRvd0JsdXIgPSAwO1xuICAgIH1cblxuICAgIGN0eC5maWxsVGV4dCh0ZXh0LCB4LCB5LCB3KTtcblxuICAgIGlmIChzaGFkb3cgJiYgc3Ryb2tlZCkge1xuICAgICAgY3R4LnNoYWRvd0JsdXIgPSBzaGFkb3c7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRyYXdUZXh0KGN0eCwgbGluZXMsIHJlY3QsIG1vZGVsKSB7XG4gIHZhciBhbGlnbiA9IG1vZGVsLnRleHRBbGlnbjtcbiAgdmFyIGNvbG9yID0gbW9kZWwuY29sb3I7XG4gIHZhciBmaWxsZWQgPSAhIWNvbG9yO1xuICB2YXIgZm9udCA9IG1vZGVsLmZvbnQ7XG4gIHZhciBpbGVuID0gbGluZXMubGVuZ3RoO1xuICB2YXIgc3Ryb2tlQ29sb3IgPSBtb2RlbC50ZXh0U3Ryb2tlQ29sb3I7XG4gIHZhciBzdHJva2VXaWR0aCA9IG1vZGVsLnRleHRTdHJva2VXaWR0aDtcbiAgdmFyIHN0cm9rZWQgPSBzdHJva2VDb2xvciAmJiBzdHJva2VXaWR0aDtcbiAgdmFyIGk7XG5cbiAgaWYgKCFpbGVuIHx8ICghZmlsbGVkICYmICFzdHJva2VkKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEFkanVzdCBjb29yZGluYXRlcyBiYXNlZCBvbiB0ZXh0IGFsaWdubWVudCBhbmQgbGluZSBoZWlnaHRcbiAgcmVjdCA9IHRleHRHZW9tZXRyeShyZWN0LCBhbGlnbiwgZm9udCk7XG5cbiAgY3R4LmZvbnQgPSBmb250LnN0cmluZztcbiAgY3R4LnRleHRBbGlnbiA9IGFsaWduO1xuICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gIGN0eC5zaGFkb3dCbHVyID0gbW9kZWwudGV4dFNoYWRvd0JsdXI7XG4gIGN0eC5zaGFkb3dDb2xvciA9IG1vZGVsLnRleHRTaGFkb3dDb2xvcjtcblxuICBpZiAoZmlsbGVkKSB7XG4gICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICB9XG4gIGlmIChzdHJva2VkKSB7XG4gICAgY3R4LmxpbmVKb2luID0gJ3JvdW5kJztcbiAgICBjdHgubGluZVdpZHRoID0gc3Ryb2tlV2lkdGg7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlQ29sb3I7XG4gIH1cblxuICBmb3IgKGkgPSAwLCBpbGVuID0gbGluZXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgZHJhd1RleHRMaW5lKGN0eCwgbGluZXNbaV0sIHtcbiAgICAgIHN0cm9rZWQ6IHN0cm9rZWQsXG4gICAgICBmaWxsZWQ6IGZpbGxlZCxcbiAgICAgIHc6IHJlY3QudyxcbiAgICAgIHg6IHJlY3QueCxcbiAgICAgIHk6IHJlY3QueSArIHJlY3QuaCAqIGlcbiAgICB9KTtcbiAgfVxufVxuXG52YXIgTGFiZWwgPSBmdW5jdGlvbihjb25maWcsIGN0eCwgZWwsIGluZGV4KSB7XG4gIHZhciBtZSA9IHRoaXM7XG5cbiAgbWUuX2NvbmZpZyA9IGNvbmZpZztcbiAgbWUuX2luZGV4ID0gaW5kZXg7XG4gIG1lLl9tb2RlbCA9IG51bGw7XG4gIG1lLl9yZWN0cyA9IG51bGw7XG4gIG1lLl9jdHggPSBjdHg7XG4gIG1lLl9lbCA9IGVsO1xufTtcblxubWVyZ2UoTGFiZWwucHJvdG90eXBlLCB7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX21vZGVsaXplOiBmdW5jdGlvbihkaXNwbGF5LCBsaW5lcywgY29uZmlnLCBjb250ZXh0KSB7XG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB2YXIgaW5kZXggPSBtZS5faW5kZXg7XG4gICAgdmFyIGZvbnQgPSB0b0ZvbnQocmVzb2x2ZShbY29uZmlnLmZvbnQsIHt9XSwgY29udGV4dCwgaW5kZXgpKTtcbiAgICB2YXIgY29sb3IgPSByZXNvbHZlKFtjb25maWcuY29sb3IsIGRlZmF1bHRzJDEuY29sb3JdLCBjb250ZXh0LCBpbmRleCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgYWxpZ246IHJlc29sdmUoW2NvbmZpZy5hbGlnbiwgJ2NlbnRlciddLCBjb250ZXh0LCBpbmRleCksXG4gICAgICBhbmNob3I6IHJlc29sdmUoW2NvbmZpZy5hbmNob3IsICdjZW50ZXInXSwgY29udGV4dCwgaW5kZXgpLFxuICAgICAgYXJlYTogY29udGV4dC5jaGFydC5jaGFydEFyZWEsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IHJlc29sdmUoW2NvbmZpZy5iYWNrZ3JvdW5kQ29sb3IsIG51bGxdLCBjb250ZXh0LCBpbmRleCksXG4gICAgICBib3JkZXJDb2xvcjogcmVzb2x2ZShbY29uZmlnLmJvcmRlckNvbG9yLCBudWxsXSwgY29udGV4dCwgaW5kZXgpLFxuICAgICAgYm9yZGVyUmFkaXVzOiByZXNvbHZlKFtjb25maWcuYm9yZGVyUmFkaXVzLCAwXSwgY29udGV4dCwgaW5kZXgpLFxuICAgICAgYm9yZGVyV2lkdGg6IHJlc29sdmUoW2NvbmZpZy5ib3JkZXJXaWR0aCwgMF0sIGNvbnRleHQsIGluZGV4KSxcbiAgICAgIGNsYW1wOiByZXNvbHZlKFtjb25maWcuY2xhbXAsIGZhbHNlXSwgY29udGV4dCwgaW5kZXgpLFxuICAgICAgY2xpcDogcmVzb2x2ZShbY29uZmlnLmNsaXAsIGZhbHNlXSwgY29udGV4dCwgaW5kZXgpLFxuICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgZGlzcGxheTogZGlzcGxheSxcbiAgICAgIGZvbnQ6IGZvbnQsXG4gICAgICBsaW5lczogbGluZXMsXG4gICAgICBvZmZzZXQ6IHJlc29sdmUoW2NvbmZpZy5vZmZzZXQsIDRdLCBjb250ZXh0LCBpbmRleCksXG4gICAgICBvcGFjaXR5OiByZXNvbHZlKFtjb25maWcub3BhY2l0eSwgMV0sIGNvbnRleHQsIGluZGV4KSxcbiAgICAgIG9yaWdpbjogZ2V0U2NhbGVPcmlnaW4obWUuX2VsLCBjb250ZXh0KSxcbiAgICAgIHBhZGRpbmc6IHRvUGFkZGluZyhyZXNvbHZlKFtjb25maWcucGFkZGluZywgNF0sIGNvbnRleHQsIGluZGV4KSksXG4gICAgICBwb3NpdGlvbmVyOiBnZXRQb3NpdGlvbmVyKG1lLl9lbCksXG4gICAgICByb3RhdGlvbjogcmVzb2x2ZShbY29uZmlnLnJvdGF0aW9uLCAwXSwgY29udGV4dCwgaW5kZXgpICogKE1hdGguUEkgLyAxODApLFxuICAgICAgc2l6ZTogdXRpbHMudGV4dFNpemUobWUuX2N0eCwgbGluZXMsIGZvbnQpLFxuICAgICAgdGV4dEFsaWduOiByZXNvbHZlKFtjb25maWcudGV4dEFsaWduLCAnc3RhcnQnXSwgY29udGV4dCwgaW5kZXgpLFxuICAgICAgdGV4dFNoYWRvd0JsdXI6IHJlc29sdmUoW2NvbmZpZy50ZXh0U2hhZG93Qmx1ciwgMF0sIGNvbnRleHQsIGluZGV4KSxcbiAgICAgIHRleHRTaGFkb3dDb2xvcjogcmVzb2x2ZShbY29uZmlnLnRleHRTaGFkb3dDb2xvciwgY29sb3JdLCBjb250ZXh0LCBpbmRleCksXG4gICAgICB0ZXh0U3Ryb2tlQ29sb3I6IHJlc29sdmUoW2NvbmZpZy50ZXh0U3Ryb2tlQ29sb3IsIGNvbG9yXSwgY29udGV4dCwgaW5kZXgpLFxuICAgICAgdGV4dFN0cm9rZVdpZHRoOiByZXNvbHZlKFtjb25maWcudGV4dFN0cm9rZVdpZHRoLCAwXSwgY29udGV4dCwgaW5kZXgpXG4gICAgfTtcbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHZhciBtb2RlbCA9IG51bGw7XG4gICAgdmFyIHJlY3RzID0gbnVsbDtcbiAgICB2YXIgaW5kZXggPSBtZS5faW5kZXg7XG4gICAgdmFyIGNvbmZpZyA9IG1lLl9jb25maWc7XG4gICAgdmFyIHZhbHVlLCBsYWJlbCwgbGluZXM7XG5cbiAgICAvLyBXZSBmaXJzdCByZXNvbHZlIHRoZSBkaXNwbGF5IG9wdGlvbiAoc2VwYXJhdGVseSkgdG8gYXZvaWQgY29tcHV0aW5nXG4gICAgLy8gb3RoZXIgb3B0aW9ucyBpbiBjYXNlIHRoZSBsYWJlbCBpcyBoaWRkZW4gKGkuZS4gZGlzcGxheTogZmFsc2UpLlxuICAgIHZhciBkaXNwbGF5ID0gcmVzb2x2ZShbY29uZmlnLmRpc3BsYXksIHRydWVdLCBjb250ZXh0LCBpbmRleCk7XG5cbiAgICBpZiAoZGlzcGxheSkge1xuICAgICAgdmFsdWUgPSBjb250ZXh0LmRhdGFzZXQuZGF0YVtpbmRleF07XG4gICAgICBsYWJlbCA9IHZhbHVlT3JEZWZhdWx0KGNhbGxiYWNrKGNvbmZpZy5mb3JtYXR0ZXIsIFt2YWx1ZSwgY29udGV4dF0pLCB2YWx1ZSk7XG4gICAgICBsaW5lcyA9IGlzTnVsbE9yVW5kZWYobGFiZWwpID8gW10gOiB1dGlscy50b1RleHRMaW5lcyhsYWJlbCk7XG5cbiAgICAgIGlmIChsaW5lcy5sZW5ndGgpIHtcbiAgICAgICAgbW9kZWwgPSBtZS5fbW9kZWxpemUoZGlzcGxheSwgbGluZXMsIGNvbmZpZywgY29udGV4dCk7XG4gICAgICAgIHJlY3RzID0gYm91bmRpbmdSZWN0cyhtb2RlbCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbWUuX21vZGVsID0gbW9kZWw7XG4gICAgbWUuX3JlY3RzID0gcmVjdHM7XG4gIH0sXG5cbiAgZ2VvbWV0cnk6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWN0cyA/IHRoaXMuX3JlY3RzLmZyYW1lIDoge307XG4gIH0sXG5cbiAgcm90YXRpb246IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9tb2RlbCA/IHRoaXMuX21vZGVsLnJvdGF0aW9uIDogMDtcbiAgfSxcblxuICB2aXNpYmxlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fbW9kZWwgJiYgdGhpcy5fbW9kZWwub3BhY2l0eTtcbiAgfSxcblxuICBtb2RlbDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX21vZGVsO1xuICB9LFxuXG4gIGRyYXc6IGZ1bmN0aW9uKGNoYXJ0LCBjZW50ZXIpIHtcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHZhciBjdHggPSBjaGFydC5jdHg7XG4gICAgdmFyIG1vZGVsID0gbWUuX21vZGVsO1xuICAgIHZhciByZWN0cyA9IG1lLl9yZWN0cztcbiAgICB2YXIgYXJlYTtcblxuICAgIGlmICghdGhpcy52aXNpYmxlKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjdHguc2F2ZSgpO1xuXG4gICAgaWYgKG1vZGVsLmNsaXApIHtcbiAgICAgIGFyZWEgPSBtb2RlbC5hcmVhO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4LnJlY3QoXG4gICAgICAgIGFyZWEubGVmdCxcbiAgICAgICAgYXJlYS50b3AsXG4gICAgICAgIGFyZWEucmlnaHQgLSBhcmVhLmxlZnQsXG4gICAgICAgIGFyZWEuYm90dG9tIC0gYXJlYS50b3ApO1xuICAgICAgY3R4LmNsaXAoKTtcbiAgICB9XG5cbiAgICBjdHguZ2xvYmFsQWxwaGEgPSB1dGlscy5ib3VuZCgwLCBtb2RlbC5vcGFjaXR5LCAxKTtcbiAgICBjdHgudHJhbnNsYXRlKHJhc3Rlcml6ZShjZW50ZXIueCksIHJhc3Rlcml6ZShjZW50ZXIueSkpO1xuICAgIGN0eC5yb3RhdGUobW9kZWwucm90YXRpb24pO1xuXG4gICAgZHJhd0ZyYW1lKGN0eCwgcmVjdHMuZnJhbWUsIG1vZGVsKTtcbiAgICBkcmF3VGV4dChjdHgsIG1vZGVsLmxpbmVzLCByZWN0cy50ZXh0LCBtb2RlbCk7XG5cbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG59KTtcblxudmFyIE1JTl9JTlRFR0VSID0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIgfHwgLTkwMDcxOTkyNTQ3NDA5OTE7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXMvbm8tbnVtYmVyLW1pbnNhZmVpbnRlZ2VyXG52YXIgTUFYX0lOVEVHRVIgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fCA5MDA3MTk5MjU0NzQwOTkxOyAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcy9uby1udW1iZXItbWF4c2FmZWludGVnZXJcblxuZnVuY3Rpb24gcm90YXRlZChwb2ludCwgY2VudGVyLCBhbmdsZSkge1xuICB2YXIgY29zID0gTWF0aC5jb3MoYW5nbGUpO1xuICB2YXIgc2luID0gTWF0aC5zaW4oYW5nbGUpO1xuICB2YXIgY3ggPSBjZW50ZXIueDtcbiAgdmFyIGN5ID0gY2VudGVyLnk7XG5cbiAgcmV0dXJuIHtcbiAgICB4OiBjeCArIGNvcyAqIChwb2ludC54IC0gY3gpIC0gc2luICogKHBvaW50LnkgLSBjeSksXG4gICAgeTogY3kgKyBzaW4gKiAocG9pbnQueCAtIGN4KSArIGNvcyAqIChwb2ludC55IC0gY3kpXG4gIH07XG59XG5cbmZ1bmN0aW9uIHByb2plY3RlZChwb2ludHMsIGF4aXMpIHtcbiAgdmFyIG1pbiA9IE1BWF9JTlRFR0VSO1xuICB2YXIgbWF4ID0gTUlOX0lOVEVHRVI7XG4gIHZhciBvcmlnaW4gPSBheGlzLm9yaWdpbjtcbiAgdmFyIGksIHB0LCB2eCwgdnksIGRwO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyArK2kpIHtcbiAgICBwdCA9IHBvaW50c1tpXTtcbiAgICB2eCA9IHB0LnggLSBvcmlnaW4ueDtcbiAgICB2eSA9IHB0LnkgLSBvcmlnaW4ueTtcbiAgICBkcCA9IGF4aXMudnggKiB2eCArIGF4aXMudnkgKiB2eTtcbiAgICBtaW4gPSBNYXRoLm1pbihtaW4sIGRwKTtcbiAgICBtYXggPSBNYXRoLm1heChtYXgsIGRwKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbWluOiBtaW4sXG4gICAgbWF4OiBtYXhcbiAgfTtcbn1cblxuZnVuY3Rpb24gdG9BeGlzKHAwLCBwMSkge1xuICB2YXIgdnggPSBwMS54IC0gcDAueDtcbiAgdmFyIHZ5ID0gcDEueSAtIHAwLnk7XG4gIHZhciBsbiA9IE1hdGguc3FydCh2eCAqIHZ4ICsgdnkgKiB2eSk7XG5cbiAgcmV0dXJuIHtcbiAgICB2eDogKHAxLnggLSBwMC54KSAvIGxuLFxuICAgIHZ5OiAocDEueSAtIHAwLnkpIC8gbG4sXG4gICAgb3JpZ2luOiBwMCxcbiAgICBsbjogbG5cbiAgfTtcbn1cblxudmFyIEhpdEJveCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9yb3RhdGlvbiA9IDA7XG4gIHRoaXMuX3JlY3QgPSB7XG4gICAgeDogMCxcbiAgICB5OiAwLFxuICAgIHc6IDAsXG4gICAgaDogMFxuICB9O1xufTtcblxubWVyZ2UoSGl0Qm94LnByb3RvdHlwZSwge1xuICBjZW50ZXI6IGZ1bmN0aW9uKCkge1xuICAgIHZhciByID0gdGhpcy5fcmVjdDtcbiAgICByZXR1cm4ge1xuICAgICAgeDogci54ICsgci53IC8gMixcbiAgICAgIHk6IHIueSArIHIuaCAvIDJcbiAgICB9O1xuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24oY2VudGVyLCByZWN0LCByb3RhdGlvbikge1xuICAgIHRoaXMuX3JvdGF0aW9uID0gcm90YXRpb247XG4gICAgdGhpcy5fcmVjdCA9IHtcbiAgICAgIHg6IHJlY3QueCArIGNlbnRlci54LFxuICAgICAgeTogcmVjdC55ICsgY2VudGVyLnksXG4gICAgICB3OiByZWN0LncsXG4gICAgICBoOiByZWN0LmhcbiAgICB9O1xuICB9LFxuXG4gIGNvbnRhaW5zOiBmdW5jdGlvbihwb2ludCkge1xuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgdmFyIG1hcmdpbiA9IDE7XG4gICAgdmFyIHJlY3QgPSBtZS5fcmVjdDtcblxuICAgIHBvaW50ID0gcm90YXRlZChwb2ludCwgbWUuY2VudGVyKCksIC1tZS5fcm90YXRpb24pO1xuXG4gICAgcmV0dXJuICEocG9pbnQueCA8IHJlY3QueCAtIG1hcmdpblxuICAgICAgfHwgcG9pbnQueSA8IHJlY3QueSAtIG1hcmdpblxuICAgICAgfHwgcG9pbnQueCA+IHJlY3QueCArIHJlY3QudyArIG1hcmdpbiAqIDJcbiAgICAgIHx8IHBvaW50LnkgPiByZWN0LnkgKyByZWN0LmggKyBtYXJnaW4gKiAyKTtcbiAgfSxcblxuICAvLyBTZXBhcmF0aW5nIEF4aXMgVGhlb3JlbVxuICAvLyBodHRwczovL2dhbWVkZXZlbG9wbWVudC50dXRzcGx1cy5jb20vdHV0b3JpYWxzL2NvbGxpc2lvbi1kZXRlY3Rpb24tdXNpbmctdGhlLXNlcGFyYXRpbmctYXhpcy10aGVvcmVtLS1nYW1lZGV2LTE2OVxuICBpbnRlcnNlY3RzOiBmdW5jdGlvbihvdGhlcikge1xuICAgIHZhciByMCA9IHRoaXMuX3BvaW50cygpO1xuICAgIHZhciByMSA9IG90aGVyLl9wb2ludHMoKTtcbiAgICB2YXIgYXhlcyA9IFtcbiAgICAgIHRvQXhpcyhyMFswXSwgcjBbMV0pLFxuICAgICAgdG9BeGlzKHIwWzBdLCByMFszXSlcbiAgICBdO1xuICAgIHZhciBpLCBwcjAsIHByMTtcblxuICAgIGlmICh0aGlzLl9yb3RhdGlvbiAhPT0gb3RoZXIuX3JvdGF0aW9uKSB7XG4gICAgICAvLyBPbmx5IHNlcGFyYXRlIHdpdGggcjEgYXhpcyBpZiB0aGUgcm90YXRpb24gaXMgZGlmZmVyZW50LFxuICAgICAgLy8gZWxzZSBpdCdzIGVub3VnaCB0byBzZXBhcmF0ZSByMCBhbmQgcjEgd2l0aCByMCBheGlzIG9ubHkhXG4gICAgICBheGVzLnB1c2goXG4gICAgICAgIHRvQXhpcyhyMVswXSwgcjFbMV0pLFxuICAgICAgICB0b0F4aXMocjFbMF0sIHIxWzNdKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgYXhlcy5sZW5ndGg7ICsraSkge1xuICAgICAgcHIwID0gcHJvamVjdGVkKHIwLCBheGVzW2ldKTtcbiAgICAgIHByMSA9IHByb2plY3RlZChyMSwgYXhlc1tpXSk7XG5cbiAgICAgIGlmIChwcjAubWF4IDwgcHIxLm1pbiB8fCBwcjEubWF4IDwgcHIwLm1pbikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcG9pbnRzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHZhciByZWN0ID0gbWUuX3JlY3Q7XG4gICAgdmFyIGFuZ2xlID0gbWUuX3JvdGF0aW9uO1xuICAgIHZhciBjZW50ZXIgPSBtZS5jZW50ZXIoKTtcblxuICAgIHJldHVybiBbXG4gICAgICByb3RhdGVkKHt4OiByZWN0LngsIHk6IHJlY3QueX0sIGNlbnRlciwgYW5nbGUpLFxuICAgICAgcm90YXRlZCh7eDogcmVjdC54ICsgcmVjdC53LCB5OiByZWN0Lnl9LCBjZW50ZXIsIGFuZ2xlKSxcbiAgICAgIHJvdGF0ZWQoe3g6IHJlY3QueCArIHJlY3QudywgeTogcmVjdC55ICsgcmVjdC5ofSwgY2VudGVyLCBhbmdsZSksXG4gICAgICByb3RhdGVkKHt4OiByZWN0LngsIHk6IHJlY3QueSArIHJlY3QuaH0sIGNlbnRlciwgYW5nbGUpXG4gICAgXTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGNvb3JkaW5hdGVzKGVsLCBtb2RlbCwgZ2VvbWV0cnkpIHtcbiAgdmFyIHBvaW50ID0gbW9kZWwucG9zaXRpb25lcihlbCwgbW9kZWwpO1xuICB2YXIgdnggPSBwb2ludC52eDtcbiAgdmFyIHZ5ID0gcG9pbnQudnk7XG5cbiAgaWYgKCF2eCAmJiAhdnkpIHtcbiAgICAvLyBpZiBhbGlnbmVkIGNlbnRlciwgd2UgZG9uJ3Qgd2FudCB0byBvZmZzZXQgdGhlIGNlbnRlciBwb2ludFxuICAgIHJldHVybiB7eDogcG9pbnQueCwgeTogcG9pbnQueX07XG4gIH1cblxuICB2YXIgdyA9IGdlb21ldHJ5Lnc7XG4gIHZhciBoID0gZ2VvbWV0cnkuaDtcblxuICAvLyB0YWtlIGluIGFjY291bnQgdGhlIGxhYmVsIHJvdGF0aW9uXG4gIHZhciByb3RhdGlvbiA9IG1vZGVsLnJvdGF0aW9uO1xuICB2YXIgZHggPSBNYXRoLmFicyh3IC8gMiAqIE1hdGguY29zKHJvdGF0aW9uKSkgKyBNYXRoLmFicyhoIC8gMiAqIE1hdGguc2luKHJvdGF0aW9uKSk7XG4gIHZhciBkeSA9IE1hdGguYWJzKHcgLyAyICogTWF0aC5zaW4ocm90YXRpb24pKSArIE1hdGguYWJzKGggLyAyICogTWF0aC5jb3Mocm90YXRpb24pKTtcblxuICAvLyBzY2FsZSB0aGUgdW5pdCB2ZWN0b3IgKHZ4LCB2eSkgdG8gZ2V0IGF0IGxlYXN0IGR4IG9yIGR5IGVxdWFsIHRvXG4gIC8vIHcgb3IgaCByZXNwZWN0aXZlbHkgKGVsc2Ugd2Ugd291bGQgY2FsY3VsYXRlIHRoZSBkaXN0YW5jZSB0byB0aGVcbiAgLy8gZWxsaXBzZSBpbnNjcmliZWQgaW4gdGhlIGJvdW5kaW5nIHJlY3QpXG4gIHZhciB2cyA9IDEgLyBNYXRoLm1heChNYXRoLmFicyh2eCksIE1hdGguYWJzKHZ5KSk7XG4gIGR4ICo9IHZ4ICogdnM7XG4gIGR5ICo9IHZ5ICogdnM7XG5cbiAgLy8gZmluYWxseSwgaW5jbHVkZSB0aGUgZXhwbGljaXQgb2Zmc2V0XG4gIGR4ICs9IG1vZGVsLm9mZnNldCAqIHZ4O1xuICBkeSArPSBtb2RlbC5vZmZzZXQgKiB2eTtcblxuICByZXR1cm4ge1xuICAgIHg6IHBvaW50LnggKyBkeCxcbiAgICB5OiBwb2ludC55ICsgZHlcbiAgfTtcbn1cblxuZnVuY3Rpb24gY29sbGlkZShsYWJlbHMsIGNvbGxpZGVyKSB7XG4gIHZhciBpLCBqLCBzMCwgczE7XG5cbiAgLy8gSU1QT1JUQU5UIEl0ZXJhdGUgaW4gdGhlIHJldmVyc2Ugb3JkZXIgc2luY2UgaXRlbXMgYXQgdGhlIGVuZCBvZiB0aGVcbiAgLy8gbGlzdCBoYXZlIGFuIGhpZ2hlciB3ZWlnaHQvcHJpb3JpdHkgYW5kIHRodXMgc2hvdWxkIGJlIGxlc3MgaW1wYWN0ZWRcbiAgLy8gYnkgdGhlIG92ZXJsYXBwaW5nIHN0cmF0ZWd5LlxuXG4gIGZvciAoaSA9IGxhYmVscy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgIHMwID0gbGFiZWxzW2ldLiRsYXlvdXQ7XG5cbiAgICBmb3IgKGogPSBpIC0gMTsgaiA+PSAwICYmIHMwLl92aXNpYmxlOyAtLWopIHtcbiAgICAgIHMxID0gbGFiZWxzW2pdLiRsYXlvdXQ7XG5cbiAgICAgIGlmIChzMS5fdmlzaWJsZSAmJiBzMC5fYm94LmludGVyc2VjdHMoczEuX2JveCkpIHtcbiAgICAgICAgY29sbGlkZXIoczAsIHMxKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbGFiZWxzO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlKGxhYmVscykge1xuICB2YXIgaSwgaWxlbiwgbGFiZWwsIHN0YXRlLCBnZW9tZXRyeSwgY2VudGVyLCBwcm94eTtcblxuICAvLyBJbml0aWFsaXplIGxhYmVscyBmb3Igb3ZlcmxhcCBkZXRlY3Rpb25cbiAgZm9yIChpID0gMCwgaWxlbiA9IGxhYmVscy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBsYWJlbCA9IGxhYmVsc1tpXTtcbiAgICBzdGF0ZSA9IGxhYmVsLiRsYXlvdXQ7XG5cbiAgICBpZiAoc3RhdGUuX3Zpc2libGUpIHtcbiAgICAgIC8vIENoYXJ0LmpzIDMgcmVtb3ZlZCBlbC5fbW9kZWwgaW4gZmF2b3Igb2YgZ2V0UHJvcHMoKSwgbWFraW5nIGhhcmRlciB0b1xuICAgICAgLy8gYWJzdHJhY3QgcmVhZGluZyB2YWx1ZXMgaW4gcG9zaXRpb25lcnMuIEFsc28sIHVzaW5nIHN0cmluZyBhcnJheXMgdG9cbiAgICAgIC8vIHJlYWQgdmFsdWVzIChpLmUuIHZhciB7YSxiLGN9ID0gZWwuZ2V0UHJvcHMoW1wiYVwiLFwiYlwiLFwiY1wiXSkpIHdvdWxkIG1ha2VcbiAgICAgIC8vIHBvc2l0aW9uZXJzIGluZWZmaWNpZW50IGluIHRoZSBub3JtYWwgY2FzZSAoaS5lLiBub3QgdGhlIGZpbmFsIHZhbHVlcylcbiAgICAgIC8vIGFuZCB0aGUgY29kZSBhIGJpdCB1Z2x5LCBzbyBsZXQncyB1c2UgYSBQcm94eSBpbnN0ZWFkLlxuICAgICAgcHJveHkgPSBuZXcgUHJveHkobGFiZWwuX2VsLCB7Z2V0OiAoZWwsIHApID0+IGVsLmdldFByb3BzKFtwXSwgdHJ1ZSlbcF19KTtcblxuICAgICAgZ2VvbWV0cnkgPSBsYWJlbC5nZW9tZXRyeSgpO1xuICAgICAgY2VudGVyID0gY29vcmRpbmF0ZXMocHJveHksIGxhYmVsLm1vZGVsKCksIGdlb21ldHJ5KTtcbiAgICAgIHN0YXRlLl9ib3gudXBkYXRlKGNlbnRlciwgZ2VvbWV0cnksIGxhYmVsLnJvdGF0aW9uKCkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEF1dG8gaGlkZSBvdmVybGFwcGluZyBsYWJlbHNcbiAgcmV0dXJuIGNvbGxpZGUobGFiZWxzLCBmdW5jdGlvbihzMCwgczEpIHtcbiAgICB2YXIgaDAgPSBzMC5faGlkYWJsZTtcbiAgICB2YXIgaDEgPSBzMS5faGlkYWJsZTtcblxuICAgIGlmICgoaDAgJiYgaDEpIHx8IGgxKSB7XG4gICAgICBzMS5fdmlzaWJsZSA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoaDApIHtcbiAgICAgIHMwLl92aXNpYmxlID0gZmFsc2U7XG4gICAgfVxuICB9KTtcbn1cblxudmFyIGxheW91dCA9IHtcbiAgcHJlcGFyZTogZnVuY3Rpb24oZGF0YXNldHMpIHtcbiAgICB2YXIgbGFiZWxzID0gW107XG4gICAgdmFyIGksIGosIGlsZW4sIGpsZW4sIGxhYmVsO1xuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgZm9yIChqID0gMCwgamxlbiA9IGRhdGFzZXRzW2ldLmxlbmd0aDsgaiA8IGpsZW47ICsraikge1xuICAgICAgICBsYWJlbCA9IGRhdGFzZXRzW2ldW2pdO1xuICAgICAgICBsYWJlbHMucHVzaChsYWJlbCk7XG4gICAgICAgIGxhYmVsLiRsYXlvdXQgPSB7XG4gICAgICAgICAgX2JveDogbmV3IEhpdEJveCgpLFxuICAgICAgICAgIF9oaWRhYmxlOiBmYWxzZSxcbiAgICAgICAgICBfdmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgICBfc2V0OiBpLFxuICAgICAgICAgIF9pZHg6IGxhYmVsLl9pbmRleFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE8gTmV3IGB6YCBvcHRpb246IGxhYmVscyB3aXRoIGEgaGlnaGVyIHotaW5kZXggYXJlIGRyYXduXG4gICAgLy8gb2YgdG9wIG9mIHRoZSBvbmVzIHdpdGggYSBsb3dlciBpbmRleC4gTG93ZXN0IHotaW5kZXggbGFiZWxzXG4gICAgLy8gYXJlIGFsc28gZGlzY2FyZGVkIGZpcnN0IHdoZW4gaGlkaW5nIG92ZXJsYXBwaW5nIGxhYmVscy5cbiAgICBsYWJlbHMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICB2YXIgc2EgPSBhLiRsYXlvdXQ7XG4gICAgICB2YXIgc2IgPSBiLiRsYXlvdXQ7XG5cbiAgICAgIHJldHVybiBzYS5faWR4ID09PSBzYi5faWR4XG4gICAgICAgID8gc2IuX3NldCAtIHNhLl9zZXRcbiAgICAgICAgOiBzYi5faWR4IC0gc2EuX2lkeDtcbiAgICB9KTtcblxuICAgIHRoaXMudXBkYXRlKGxhYmVscyk7XG5cbiAgICByZXR1cm4gbGFiZWxzO1xuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24obGFiZWxzKSB7XG4gICAgdmFyIGRpcnR5ID0gZmFsc2U7XG4gICAgdmFyIGksIGlsZW4sIGxhYmVsLCBtb2RlbCwgc3RhdGU7XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbGFiZWxzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgbGFiZWwgPSBsYWJlbHNbaV07XG4gICAgICBtb2RlbCA9IGxhYmVsLm1vZGVsKCk7XG4gICAgICBzdGF0ZSA9IGxhYmVsLiRsYXlvdXQ7XG4gICAgICBzdGF0ZS5faGlkYWJsZSA9IG1vZGVsICYmIG1vZGVsLmRpc3BsYXkgPT09ICdhdXRvJztcbiAgICAgIHN0YXRlLl92aXNpYmxlID0gbGFiZWwudmlzaWJsZSgpO1xuICAgICAgZGlydHkgfD0gc3RhdGUuX2hpZGFibGU7XG4gICAgfVxuXG4gICAgaWYgKGRpcnR5KSB7XG4gICAgICBjb21wdXRlKGxhYmVscyk7XG4gICAgfVxuICB9LFxuXG4gIGxvb2t1cDogZnVuY3Rpb24obGFiZWxzLCBwb2ludCkge1xuICAgIHZhciBpLCBzdGF0ZTtcblxuICAgIC8vIElNUE9SVEFOVCBJdGVyYXRlIGluIHRoZSByZXZlcnNlIG9yZGVyIHNpbmNlIGl0ZW1zIGF0IHRoZSBlbmQgb2ZcbiAgICAvLyB0aGUgbGlzdCBoYXZlIGFuIGhpZ2hlciB6LWluZGV4LCB0aHVzIHNob3VsZCBiZSBwaWNrZWQgZmlyc3QuXG5cbiAgICBmb3IgKGkgPSBsYWJlbHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHN0YXRlID0gbGFiZWxzW2ldLiRsYXlvdXQ7XG5cbiAgICAgIGlmIChzdGF0ZSAmJiBzdGF0ZS5fdmlzaWJsZSAmJiBzdGF0ZS5fYm94LmNvbnRhaW5zKHBvaW50KSkge1xuICAgICAgICByZXR1cm4gbGFiZWxzW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9LFxuXG4gIGRyYXc6IGZ1bmN0aW9uKGNoYXJ0LCBsYWJlbHMpIHtcbiAgICB2YXIgaSwgaWxlbiwgbGFiZWwsIHN0YXRlLCBnZW9tZXRyeSwgY2VudGVyO1xuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGxhYmVscy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGxhYmVsID0gbGFiZWxzW2ldO1xuICAgICAgc3RhdGUgPSBsYWJlbC4kbGF5b3V0O1xuXG4gICAgICBpZiAoc3RhdGUuX3Zpc2libGUpIHtcbiAgICAgICAgZ2VvbWV0cnkgPSBsYWJlbC5nZW9tZXRyeSgpO1xuICAgICAgICBjZW50ZXIgPSBjb29yZGluYXRlcyhsYWJlbC5fZWwsIGxhYmVsLm1vZGVsKCksIGdlb21ldHJ5KTtcbiAgICAgICAgc3RhdGUuX2JveC51cGRhdGUoY2VudGVyLCBnZW9tZXRyeSwgbGFiZWwucm90YXRpb24oKSk7XG4gICAgICAgIGxhYmVsLmRyYXcoY2hhcnQsIGNlbnRlcik7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgZm9ybWF0dGVyID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKGlzTnVsbE9yVW5kZWYodmFsdWUpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbGFiZWwgPSB2YWx1ZTtcbiAgdmFyIGtleXMsIGtsZW4sIGs7XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICBpZiAoIWlzTnVsbE9yVW5kZWYodmFsdWUubGFiZWwpKSB7XG4gICAgICBsYWJlbCA9IHZhbHVlLmxhYmVsO1xuICAgIH0gZWxzZSBpZiAoIWlzTnVsbE9yVW5kZWYodmFsdWUucikpIHtcbiAgICAgIGxhYmVsID0gdmFsdWUucjtcbiAgICB9IGVsc2Uge1xuICAgICAgbGFiZWwgPSAnJztcbiAgICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gICAgICBmb3IgKGsgPSAwLCBrbGVuID0ga2V5cy5sZW5ndGg7IGsgPCBrbGVuOyArK2spIHtcbiAgICAgICAgbGFiZWwgKz0gKGsgIT09IDAgPyAnLCAnIDogJycpICsga2V5c1trXSArICc6ICcgKyB2YWx1ZVtrZXlzW2tdXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gJycgKyBsYWJlbDtcbn07XG5cbi8qKlxuICogSU1QT1JUQU5UOiBtYWtlIHN1cmUgdG8gYWxzbyB1cGRhdGUgdGVzdHMgYW5kIFR5cGVTY3JpcHQgZGVmaW5pdGlvblxuICogZmlsZXMgKGAvdGVzdC9zcGVjcy9kZWZhdWx0cy5zcGVjLmpzYCBhbmQgYC90eXBlcy9vcHRpb25zLmQudHNgKVxuICovXG5cbnZhciBkZWZhdWx0cyA9IHtcbiAgYWxpZ246ICdjZW50ZXInLFxuICBhbmNob3I6ICdjZW50ZXInLFxuICBiYWNrZ3JvdW5kQ29sb3I6IG51bGwsXG4gIGJvcmRlckNvbG9yOiBudWxsLFxuICBib3JkZXJSYWRpdXM6IDAsXG4gIGJvcmRlcldpZHRoOiAwLFxuICBjbGFtcDogZmFsc2UsXG4gIGNsaXA6IGZhbHNlLFxuICBjb2xvcjogdW5kZWZpbmVkLFxuICBkaXNwbGF5OiB0cnVlLFxuICBmb250OiB7XG4gICAgZmFtaWx5OiB1bmRlZmluZWQsXG4gICAgbGluZUhlaWdodDogMS4yLFxuICAgIHNpemU6IHVuZGVmaW5lZCxcbiAgICBzdHlsZTogdW5kZWZpbmVkLFxuICAgIHdlaWdodDogbnVsbFxuICB9LFxuICBmb3JtYXR0ZXI6IGZvcm1hdHRlcixcbiAgbGFiZWxzOiB1bmRlZmluZWQsXG4gIGxpc3RlbmVyczoge30sXG4gIG9mZnNldDogNCxcbiAgb3BhY2l0eTogMSxcbiAgcGFkZGluZzoge1xuICAgIHRvcDogNCxcbiAgICByaWdodDogNCxcbiAgICBib3R0b206IDQsXG4gICAgbGVmdDogNFxuICB9LFxuICByb3RhdGlvbjogMCxcbiAgdGV4dEFsaWduOiAnc3RhcnQnLFxuICB0ZXh0U3Ryb2tlQ29sb3I6IHVuZGVmaW5lZCxcbiAgdGV4dFN0cm9rZVdpZHRoOiAwLFxuICB0ZXh0U2hhZG93Qmx1cjogMCxcbiAgdGV4dFNoYWRvd0NvbG9yOiB1bmRlZmluZWRcbn07XG5cbi8qKlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNDE3NlxuICovXG5cbnZhciBFWFBBTkRPX0tFWSA9ICckZGF0YWxhYmVscyc7XG52YXIgREVGQVVMVF9LRVkgPSAnJGRlZmF1bHQnO1xuXG5mdW5jdGlvbiBjb25maWd1cmUoZGF0YXNldCwgb3B0aW9ucykge1xuICB2YXIgb3ZlcnJpZGUgPSBkYXRhc2V0LmRhdGFsYWJlbHM7XG4gIHZhciBsaXN0ZW5lcnMgPSB7fTtcbiAgdmFyIGNvbmZpZ3MgPSBbXTtcbiAgdmFyIGxhYmVscywga2V5cztcblxuICBpZiAob3ZlcnJpZGUgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKG92ZXJyaWRlID09PSB0cnVlKSB7XG4gICAgb3ZlcnJpZGUgPSB7fTtcbiAgfVxuXG4gIG9wdGlvbnMgPSBtZXJnZSh7fSwgW29wdGlvbnMsIG92ZXJyaWRlXSk7XG4gIGxhYmVscyA9IG9wdGlvbnMubGFiZWxzIHx8IHt9O1xuICBrZXlzID0gT2JqZWN0LmtleXMobGFiZWxzKTtcbiAgZGVsZXRlIG9wdGlvbnMubGFiZWxzO1xuXG4gIGlmIChrZXlzLmxlbmd0aCkge1xuICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgIGlmIChsYWJlbHNba2V5XSkge1xuICAgICAgICBjb25maWdzLnB1c2gobWVyZ2Uoe30sIFtcbiAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgIGxhYmVsc1trZXldLFxuICAgICAgICAgIHtfa2V5OiBrZXl9XG4gICAgICAgIF0pKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBEZWZhdWx0IGxhYmVsIGlmIG5vIFwibmFtZWRcIiBsYWJlbCBkZWZpbmVkLlxuICAgIGNvbmZpZ3MucHVzaChvcHRpb25zKTtcbiAgfVxuXG4gIC8vIGxpc3RlbmVyczogezxldmVudC10eXBlPjogezxsYWJlbC1rZXk+OiA8Zm4+fX1cbiAgbGlzdGVuZXJzID0gY29uZmlncy5yZWR1Y2UoZnVuY3Rpb24odGFyZ2V0LCBjb25maWcpIHtcbiAgICBlYWNoKGNvbmZpZy5saXN0ZW5lcnMgfHwge30sIGZ1bmN0aW9uKGZuLCBldmVudCkge1xuICAgICAgdGFyZ2V0W2V2ZW50XSA9IHRhcmdldFtldmVudF0gfHwge307XG4gICAgICB0YXJnZXRbZXZlbnRdW2NvbmZpZy5fa2V5IHx8IERFRkFVTFRfS0VZXSA9IGZuO1xuICAgIH0pO1xuXG4gICAgZGVsZXRlIGNvbmZpZy5saXN0ZW5lcnM7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfSwge30pO1xuXG4gIHJldHVybiB7XG4gICAgbGFiZWxzOiBjb25maWdzLFxuICAgIGxpc3RlbmVyczogbGlzdGVuZXJzXG4gIH07XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQoY2hhcnQsIGxpc3RlbmVycywgbGFiZWwsIGV2ZW50KSB7XG4gIGlmICghbGlzdGVuZXJzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGNvbnRleHQgPSBsYWJlbC4kY29udGV4dDtcbiAgdmFyIGdyb3VwcyA9IGxhYmVsLiRncm91cHM7XG4gIHZhciBjYWxsYmFjayQxO1xuXG4gIGlmICghbGlzdGVuZXJzW2dyb3Vwcy5fc2V0XSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNhbGxiYWNrJDEgPSBsaXN0ZW5lcnNbZ3JvdXBzLl9zZXRdW2dyb3Vwcy5fa2V5XTtcbiAgaWYgKCFjYWxsYmFjayQxKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGNhbGxiYWNrKGNhbGxiYWNrJDEsIFtjb250ZXh0LCBldmVudF0pID09PSB0cnVlKSB7XG4gICAgLy8gVXNlcnMgYXJlIGFsbG93ZWQgdG8gdHdlYWsgdGhlIGdpdmVuIGNvbnRleHQgYnkgaW5qZWN0aW5nIHZhbHVlcyB0aGF0IGNhbiBiZVxuICAgIC8vIHVzZWQgaW4gc2NyaXB0YWJsZSBvcHRpb25zIHRvIGRpc3BsYXkgbGFiZWxzIGRpZmZlcmVudGx5IGJhc2VkIG9uIHRoZSBjdXJyZW50XG4gICAgLy8gZXZlbnQgKGUuZy4gaGlnaGxpZ2h0IGFuIGhvdmVyZWQgbGFiZWwpLiBUaGF0J3Mgd2h5IHdlIHVwZGF0ZSB0aGUgbGFiZWwgd2l0aFxuICAgIC8vIHRoZSBvdXRwdXQgY29udGV4dCBhbmQgc2NoZWR1bGUgYSBuZXcgY2hhcnQgcmVuZGVyIGJ5IHNldHRpbmcgaXQgZGlydHkuXG4gICAgY2hhcnRbRVhQQU5ET19LRVldLl9kaXJ0eSA9IHRydWU7XG4gICAgbGFiZWwudXBkYXRlKGNvbnRleHQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoTW92ZUV2ZW50cyhjaGFydCwgbGlzdGVuZXJzLCBwcmV2aW91cywgbGFiZWwsIGV2ZW50KSB7XG4gIHZhciBlbnRlciwgbGVhdmU7XG5cbiAgaWYgKCFwcmV2aW91cyAmJiAhbGFiZWwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoIXByZXZpb3VzKSB7XG4gICAgZW50ZXIgPSB0cnVlO1xuICB9IGVsc2UgaWYgKCFsYWJlbCkge1xuICAgIGxlYXZlID0gdHJ1ZTtcbiAgfSBlbHNlIGlmIChwcmV2aW91cyAhPT0gbGFiZWwpIHtcbiAgICBsZWF2ZSA9IGVudGVyID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChsZWF2ZSkge1xuICAgIGRpc3BhdGNoRXZlbnQoY2hhcnQsIGxpc3RlbmVycy5sZWF2ZSwgcHJldmlvdXMsIGV2ZW50KTtcbiAgfVxuICBpZiAoZW50ZXIpIHtcbiAgICBkaXNwYXRjaEV2ZW50KGNoYXJ0LCBsaXN0ZW5lcnMuZW50ZXIsIGxhYmVsLCBldmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlTW92ZUV2ZW50cyhjaGFydCwgZXZlbnQpIHtcbiAgdmFyIGV4cGFuZG8gPSBjaGFydFtFWFBBTkRPX0tFWV07XG4gIHZhciBsaXN0ZW5lcnMgPSBleHBhbmRvLl9saXN0ZW5lcnM7XG4gIHZhciBwcmV2aW91cywgbGFiZWw7XG5cbiAgaWYgKCFsaXN0ZW5lcnMuZW50ZXIgJiYgIWxpc3RlbmVycy5sZWF2ZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChldmVudC50eXBlID09PSAnbW91c2Vtb3ZlJykge1xuICAgIGxhYmVsID0gbGF5b3V0Lmxvb2t1cChleHBhbmRvLl9sYWJlbHMsIGV2ZW50KTtcbiAgfSBlbHNlIGlmIChldmVudC50eXBlICE9PSAnbW91c2VvdXQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcHJldmlvdXMgPSBleHBhbmRvLl9ob3ZlcmVkO1xuICBleHBhbmRvLl9ob3ZlcmVkID0gbGFiZWw7XG4gIGRpc3BhdGNoTW92ZUV2ZW50cyhjaGFydCwgbGlzdGVuZXJzLCBwcmV2aW91cywgbGFiZWwsIGV2ZW50KTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlQ2xpY2tFdmVudHMoY2hhcnQsIGV2ZW50KSB7XG4gIHZhciBleHBhbmRvID0gY2hhcnRbRVhQQU5ET19LRVldO1xuICB2YXIgaGFuZGxlcnMgPSBleHBhbmRvLl9saXN0ZW5lcnMuY2xpY2s7XG4gIHZhciBsYWJlbCA9IGhhbmRsZXJzICYmIGxheW91dC5sb29rdXAoZXhwYW5kby5fbGFiZWxzLCBldmVudCk7XG4gIGlmIChsYWJlbCkge1xuICAgIGRpc3BhdGNoRXZlbnQoY2hhcnQsIGhhbmRsZXJzLCBsYWJlbCwgZXZlbnQpO1xuICB9XG59XG5cbnZhciBwbHVnaW4gPSB7XG4gIGlkOiAnZGF0YWxhYmVscycsXG5cbiAgZGVmYXVsdHM6IGRlZmF1bHRzLFxuXG4gIGJlZm9yZUluaXQ6IGZ1bmN0aW9uKGNoYXJ0KSB7XG4gICAgY2hhcnRbRVhQQU5ET19LRVldID0ge1xuICAgICAgX2FjdGl2ZXM6IFtdXG4gICAgfTtcbiAgfSxcblxuICBiZWZvcmVVcGRhdGU6IGZ1bmN0aW9uKGNoYXJ0KSB7XG4gICAgdmFyIGV4cGFuZG8gPSBjaGFydFtFWFBBTkRPX0tFWV07XG4gICAgZXhwYW5kby5fbGlzdGVuZWQgPSBmYWxzZTtcbiAgICBleHBhbmRvLl9saXN0ZW5lcnMgPSB7fTsgICAgIC8vIHs8ZXZlbnQtdHlwZT46IHs8ZGF0YXNldC1pbmRleD46IHs8bGFiZWwta2V5PjogPGZuPn19fVxuICAgIGV4cGFuZG8uX2RhdGFzZXRzID0gW107ICAgICAgLy8gcGVyIGRhdGFzZXQgbGFiZWxzOiBbTGFiZWxbXV1cbiAgICBleHBhbmRvLl9sYWJlbHMgPSBbXTsgICAgICAgIC8vIGxheW91dGVkIGxhYmVsczogTGFiZWxbXVxuICB9LFxuXG4gIGFmdGVyRGF0YXNldFVwZGF0ZTogZnVuY3Rpb24oY2hhcnQsIGFyZ3MsIG9wdGlvbnMpIHtcbiAgICB2YXIgZGF0YXNldEluZGV4ID0gYXJncy5pbmRleDtcbiAgICB2YXIgZXhwYW5kbyA9IGNoYXJ0W0VYUEFORE9fS0VZXTtcbiAgICB2YXIgbGFiZWxzID0gZXhwYW5kby5fZGF0YXNldHNbZGF0YXNldEluZGV4XSA9IFtdO1xuICAgIHZhciB2aXNpYmxlID0gY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShkYXRhc2V0SW5kZXgpO1xuICAgIHZhciBkYXRhc2V0ID0gY2hhcnQuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdO1xuICAgIHZhciBjb25maWcgPSBjb25maWd1cmUoZGF0YXNldCwgb3B0aW9ucyk7XG4gICAgdmFyIGVsZW1lbnRzID0gYXJncy5tZXRhLmRhdGEgfHwgW107XG4gICAgdmFyIGN0eCA9IGNoYXJ0LmN0eDtcbiAgICB2YXIgaSwgaiwgaWxlbiwgamxlbiwgY2ZnLCBrZXksIGVsLCBsYWJlbDtcblxuICAgIGN0eC5zYXZlKCk7XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBlbCA9IGVsZW1lbnRzW2ldO1xuICAgICAgZWxbRVhQQU5ET19LRVldID0gW107XG5cbiAgICAgIGlmICh2aXNpYmxlICYmIGVsICYmIGNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpICYmICFlbC5za2lwKSB7XG4gICAgICAgIGZvciAoaiA9IDAsIGpsZW4gPSBjb25maWcubGFiZWxzLmxlbmd0aDsgaiA8IGpsZW47ICsraikge1xuICAgICAgICAgIGNmZyA9IGNvbmZpZy5sYWJlbHNbal07XG4gICAgICAgICAga2V5ID0gY2ZnLl9rZXk7XG5cbiAgICAgICAgICBsYWJlbCA9IG5ldyBMYWJlbChjZmcsIGN0eCwgZWwsIGkpO1xuICAgICAgICAgIGxhYmVsLiRncm91cHMgPSB7XG4gICAgICAgICAgICBfc2V0OiBkYXRhc2V0SW5kZXgsXG4gICAgICAgICAgICBfa2V5OiBrZXkgfHwgREVGQVVMVF9LRVlcbiAgICAgICAgICB9O1xuICAgICAgICAgIGxhYmVsLiRjb250ZXh0ID0ge1xuICAgICAgICAgICAgYWN0aXZlOiBmYWxzZSxcbiAgICAgICAgICAgIGNoYXJ0OiBjaGFydCxcbiAgICAgICAgICAgIGRhdGFJbmRleDogaSxcbiAgICAgICAgICAgIGRhdGFzZXQ6IGRhdGFzZXQsXG4gICAgICAgICAgICBkYXRhc2V0SW5kZXg6IGRhdGFzZXRJbmRleFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBsYWJlbC51cGRhdGUobGFiZWwuJGNvbnRleHQpO1xuICAgICAgICAgIGVsW0VYUEFORE9fS0VZXS5wdXNoKGxhYmVsKTtcbiAgICAgICAgICBsYWJlbHMucHVzaChsYWJlbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjdHgucmVzdG9yZSgpO1xuXG4gICAgLy8gU3RvcmUgbGlzdGVuZXJzIGF0IHRoZSBjaGFydCBsZXZlbCBhbmQgcGVyIGV2ZW50IHR5cGUgdG8gb3B0aW1pemVcbiAgICAvLyBjYXNlcyB3aGVyZSBubyBsaXN0ZW5lcnMgYXJlIHJlZ2lzdGVyZWQgZm9yIGEgc3BlY2lmaWMgZXZlbnQuXG4gICAgbWVyZ2UoZXhwYW5kby5fbGlzdGVuZXJzLCBjb25maWcubGlzdGVuZXJzLCB7XG4gICAgICBtZXJnZXI6IGZ1bmN0aW9uKGV2ZW50LCB0YXJnZXQsIHNvdXJjZSkge1xuICAgICAgICB0YXJnZXRbZXZlbnRdID0gdGFyZ2V0W2V2ZW50XSB8fCB7fTtcbiAgICAgICAgdGFyZ2V0W2V2ZW50XVthcmdzLmluZGV4XSA9IHNvdXJjZVtldmVudF07XG4gICAgICAgIGV4cGFuZG8uX2xpc3RlbmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICBhZnRlclVwZGF0ZTogZnVuY3Rpb24oY2hhcnQpIHtcbiAgICBjaGFydFtFWFBBTkRPX0tFWV0uX2xhYmVscyA9IGxheW91dC5wcmVwYXJlKGNoYXJ0W0VYUEFORE9fS0VZXS5fZGF0YXNldHMpO1xuICB9LFxuXG4gIC8vIERyYXcgbGFiZWxzIG9uIHRvcCBvZiBhbGwgZGF0YXNldCBlbGVtZW50c1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9jaGFydGpzLXBsdWdpbi1kYXRhbGFiZWxzL2lzc3Vlcy8yOVxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9jaGFydGpzLXBsdWdpbi1kYXRhbGFiZWxzL2lzc3Vlcy8zMlxuICBhZnRlckRhdGFzZXRzRHJhdzogZnVuY3Rpb24oY2hhcnQpIHtcbiAgICBsYXlvdXQuZHJhdyhjaGFydCwgY2hhcnRbRVhQQU5ET19LRVldLl9sYWJlbHMpO1xuICB9LFxuXG4gIGJlZm9yZUV2ZW50OiBmdW5jdGlvbihjaGFydCwgYXJncykge1xuICAgIC8vIElmIHRoZXJlIGlzIG5vIGxpc3RlbmVyIHJlZ2lzdGVyZWQgZm9yIHRoaXMgY2hhcnQsIGBsaXN0ZW5lZGAgd2lsbCBiZSBmYWxzZSxcbiAgICAvLyBtZWFuaW5nIHdlIGNhbiBpbW1lZGlhdGVseSBpZ25vcmUgdGhlIGluY29taW5nIGV2ZW50IGFuZCBhdm9pZCB1c2VsZXNzIGV4dHJhXG4gICAgLy8gY29tcHV0YXRpb24gZm9yIHVzZXJzIHdobyBkb24ndCBpbXBsZW1lbnQgbGFiZWwgaW50ZXJhY3Rpb25zLlxuICAgIGlmIChjaGFydFtFWFBBTkRPX0tFWV0uX2xpc3RlbmVkKSB7XG4gICAgICB2YXIgZXZlbnQgPSBhcmdzLmV2ZW50O1xuICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICBjYXNlICdtb3VzZW1vdmUnOlxuICAgICAgY2FzZSAnbW91c2VvdXQnOlxuICAgICAgICBoYW5kbGVNb3ZlRXZlbnRzKGNoYXJ0LCBldmVudCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnY2xpY2snOlxuICAgICAgICBoYW5kbGVDbGlja0V2ZW50cyhjaGFydCwgZXZlbnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgYWZ0ZXJFdmVudDogZnVuY3Rpb24oY2hhcnQpIHtcbiAgICB2YXIgZXhwYW5kbyA9IGNoYXJ0W0VYUEFORE9fS0VZXTtcbiAgICB2YXIgcHJldmlvdXMgPSBleHBhbmRvLl9hY3RpdmVzO1xuICAgIHZhciBhY3RpdmVzID0gZXhwYW5kby5fYWN0aXZlcyA9IGNoYXJ0LmdldEFjdGl2ZUVsZW1lbnRzKCk7XG4gICAgdmFyIHVwZGF0ZXMgPSB1dGlscy5hcnJheURpZmYocHJldmlvdXMsIGFjdGl2ZXMpO1xuICAgIHZhciBpLCBpbGVuLCBqLCBqbGVuLCB1cGRhdGUsIGxhYmVsLCBsYWJlbHM7XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdXBkYXRlcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHVwZGF0ZSA9IHVwZGF0ZXNbaV07XG4gICAgICBpZiAodXBkYXRlWzFdKSB7XG4gICAgICAgIGxhYmVscyA9IHVwZGF0ZVswXS5lbGVtZW50W0VYUEFORE9fS0VZXSB8fCBbXTtcbiAgICAgICAgZm9yIChqID0gMCwgamxlbiA9IGxhYmVscy5sZW5ndGg7IGogPCBqbGVuOyArK2opIHtcbiAgICAgICAgICBsYWJlbCA9IGxhYmVsc1tqXTtcbiAgICAgICAgICBsYWJlbC4kY29udGV4dC5hY3RpdmUgPSAodXBkYXRlWzFdID09PSAxKTtcbiAgICAgICAgICBsYWJlbC51cGRhdGUobGFiZWwuJGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGV4cGFuZG8uX2RpcnR5IHx8IHVwZGF0ZXMubGVuZ3RoKSB7XG4gICAgICBsYXlvdXQudXBkYXRlKGV4cGFuZG8uX2xhYmVscyk7XG4gICAgICBjaGFydC5yZW5kZXIoKTtcbiAgICB9XG5cbiAgICBkZWxldGUgZXhwYW5kby5fZGlydHk7XG4gIH1cbn07XG5cbmV4cG9ydCB7IHBsdWdpbiBhcyBkZWZhdWx0IH07XG4iXSwibmFtZXMiOlsiaXNOdWxsT3JVbmRlZiIsIm1lcmdlIiwidG9Gb250IiwicmVzb2x2ZSIsInRvUGFkZGluZyIsInZhbHVlT3JEZWZhdWx0IiwiY2FsbGJhY2siLCJpc09iamVjdCIsImVhY2giLCJkZWZhdWx0cyIsImRlZmF1bHRzJDEiLCJBcmNFbGVtZW50IiwiUG9pbnRFbGVtZW50IiwiQmFyRWxlbWVudCIsImRldmljZVBpeGVsUmF0aW8iLCJ3aW5kb3ciLCJzY3JlZW4iLCJkZXZpY2VYRFBJIiwibG9naWNhbFhEUEkiLCJ1dGlscyIsInRvVGV4dExpbmVzIiwiaW5wdXRzIiwibGluZXMiLCJpbnB1dCIsImNvbmNhdCIsImxlbmd0aCIsInBvcCIsInVuc2hpZnQiLCJhcHBseSIsInNwbGl0IiwiQXJyYXkiLCJpc0FycmF5IiwicHVzaCIsInRleHRTaXplIiwiY3R4IiwiZm9udCIsIml0ZW1zIiwiaWxlbiIsInByZXYiLCJ3aWR0aCIsImkiLCJzdHJpbmciLCJNYXRoIiwibWF4IiwibWVhc3VyZVRleHQiLCJoZWlnaHQiLCJsaW5lSGVpZ2h0IiwiYm91bmQiLCJtaW4iLCJ2YWx1ZSIsImFycmF5RGlmZiIsImEwIiwiYTEiLCJzbGljZSIsInVwZGF0ZXMiLCJqIiwidiIsImluZGV4T2YiLCJzcGxpY2UiLCJyYXN0ZXJpemUiLCJyb3VuZCIsIm9yaWVudCIsInBvaW50Iiwib3JpZ2luIiwieDAiLCJ4IiwieTAiLCJ5IiwiZHgiLCJkeSIsImxuIiwic3FydCIsImFsaWduZWQiLCJ2eCIsInZ5IiwiYWxpZ24iLCJQSSIsImNvcyIsInNpbiIsIlJfSU5TSURFIiwiUl9MRUZUIiwiUl9SSUdIVCIsIlJfQk9UVE9NIiwiUl9UT1AiLCJyZWdpb24iLCJyZWN0IiwicmVzIiwibGVmdCIsInJpZ2h0IiwidG9wIiwiYm90dG9tIiwiY2xpcHBlZCIsInNlZ21lbnQiLCJhcmVhIiwieDEiLCJ5MSIsInIwIiwicjEiLCJyIiwiY29tcHV0ZSQxIiwicmFuZ2UiLCJjb25maWciLCJhbmNob3IiLCJjbGFtcCIsInBvc2l0aW9uZXJzIiwiYXJjIiwiZWwiLCJhbmdsZSIsInN0YXJ0QW5nbGUiLCJlbmRBbmdsZSIsImlubmVyUmFkaXVzIiwib3V0ZXJSYWRpdXMiLCJyeCIsIm9wdGlvbnMiLCJyYWRpdXMiLCJyeSIsImJhciIsInN4Iiwic3kiLCJob3Jpem9udGFsIiwiYmFzZSIsImFicyIsImZhbGxiYWNrIiwiYm91bmRpbmdSZWN0cyIsIm1vZGVsIiwiYm9yZGVyV2lkdGgiLCJwYWRkaW5nIiwidGgiLCJzaXplIiwidHciLCJ0eCIsInR5IiwiZnJhbWUiLCJ3IiwiaCIsInRleHQiLCJnZXRTY2FsZU9yaWdpbiIsImNvbnRleHQiLCJzY2FsZSIsImNoYXJ0IiwiZ2V0RGF0YXNldE1ldGEiLCJkYXRhc2V0SW5kZXgiLCJ2U2NhbGUiLCJ4Q2VudGVyIiwidW5kZWZpbmVkIiwieUNlbnRlciIsInBpeGVsIiwiZ2V0QmFzZVBpeGVsIiwiZ2V0UG9zaXRpb25lciIsImRyYXdSb3VuZGVkUmVjdCIsIkhBTEZfUEkiLCJtb3ZlVG8iLCJjbG9zZVBhdGgiLCJkcmF3RnJhbWUiLCJiZ0NvbG9yIiwiYmFja2dyb3VuZENvbG9yIiwiYm9yZGVyQ29sb3IiLCJiZWdpblBhdGgiLCJib3JkZXJSYWRpdXMiLCJmaWxsU3R5bGUiLCJmaWxsIiwic3Ryb2tlU3R5bGUiLCJsaW5lV2lkdGgiLCJsaW5lSm9pbiIsInN0cm9rZSIsInRleHRHZW9tZXRyeSIsImRyYXdUZXh0TGluZSIsImNmZyIsInNoYWRvdyIsInNoYWRvd0JsdXIiLCJzdHJva2VkIiwic3Ryb2tlVGV4dCIsImZpbGxlZCIsImZpbGxUZXh0IiwiZHJhd1RleHQiLCJ0ZXh0QWxpZ24iLCJjb2xvciIsInN0cm9rZUNvbG9yIiwidGV4dFN0cm9rZUNvbG9yIiwic3Ryb2tlV2lkdGgiLCJ0ZXh0U3Ryb2tlV2lkdGgiLCJ0ZXh0QmFzZWxpbmUiLCJ0ZXh0U2hhZG93Qmx1ciIsInNoYWRvd0NvbG9yIiwidGV4dFNoYWRvd0NvbG9yIiwiTGFiZWwiLCJpbmRleCIsIm1lIiwiX2NvbmZpZyIsIl9pbmRleCIsIl9tb2RlbCIsIl9yZWN0cyIsIl9jdHgiLCJfZWwiLCJwcm90b3R5cGUiLCJfbW9kZWxpemUiLCJkaXNwbGF5IiwiY2hhcnRBcmVhIiwiY2xpcCIsIm9mZnNldCIsIm9wYWNpdHkiLCJwb3NpdGlvbmVyIiwicm90YXRpb24iLCJ1cGRhdGUiLCJyZWN0cyIsImxhYmVsIiwiZGF0YXNldCIsImRhdGEiLCJmb3JtYXR0ZXIiLCJnZW9tZXRyeSIsInZpc2libGUiLCJkcmF3IiwiY2VudGVyIiwic2F2ZSIsImdsb2JhbEFscGhhIiwidHJhbnNsYXRlIiwicm90YXRlIiwicmVzdG9yZSIsIk1JTl9JTlRFR0VSIiwiTnVtYmVyIiwiTUlOX1NBRkVfSU5URUdFUiIsIk1BWF9JTlRFR0VSIiwiTUFYX1NBRkVfSU5URUdFUiIsInJvdGF0ZWQiLCJjeCIsImN5IiwicHJvamVjdGVkIiwicG9pbnRzIiwiYXhpcyIsInB0IiwiZHAiLCJ0b0F4aXMiLCJwMCIsInAxIiwiSGl0Qm94IiwiX3JvdGF0aW9uIiwiX3JlY3QiLCJjb250YWlucyIsIm1hcmdpbiIsImludGVyc2VjdHMiLCJvdGhlciIsIl9wb2ludHMiLCJheGVzIiwicHIwIiwicHIxIiwiY29vcmRpbmF0ZXMiLCJ2cyIsImNvbGxpZGUiLCJsYWJlbHMiLCJjb2xsaWRlciIsInMwIiwiczEiLCIkbGF5b3V0IiwiX3Zpc2libGUiLCJfYm94IiwiY29tcHV0ZSIsInN0YXRlIiwicHJveHkiLCJQcm94eSIsImdldCIsInAiLCJnZXRQcm9wcyIsImgwIiwiX2hpZGFibGUiLCJoMSIsImxheW91dCIsInByZXBhcmUiLCJkYXRhc2V0cyIsImpsZW4iLCJfc2V0IiwiX2lkeCIsInNvcnQiLCJhIiwiYiIsInNhIiwic2IiLCJkaXJ0eSIsImxvb2t1cCIsImtleXMiLCJrbGVuIiwiayIsIk9iamVjdCIsImZhbWlseSIsInN0eWxlIiwid2VpZ2h0IiwibGlzdGVuZXJzIiwiRVhQQU5ET19LRVkiLCJERUZBVUxUX0tFWSIsImNvbmZpZ3VyZSIsIm92ZXJyaWRlIiwiZGF0YWxhYmVscyIsImNvbmZpZ3MiLCJmb3JFYWNoIiwia2V5IiwiX2tleSIsInJlZHVjZSIsInRhcmdldCIsImZuIiwiZXZlbnQiLCJkaXNwYXRjaEV2ZW50IiwiJGNvbnRleHQiLCJncm91cHMiLCIkZ3JvdXBzIiwiY2FsbGJhY2skMSIsIl9kaXJ0eSIsImRpc3BhdGNoTW92ZUV2ZW50cyIsInByZXZpb3VzIiwiZW50ZXIiLCJsZWF2ZSIsImhhbmRsZU1vdmVFdmVudHMiLCJleHBhbmRvIiwiX2xpc3RlbmVycyIsInR5cGUiLCJfbGFiZWxzIiwiX2hvdmVyZWQiLCJoYW5kbGVDbGlja0V2ZW50cyIsImhhbmRsZXJzIiwiY2xpY2siLCJwbHVnaW4iLCJpZCIsImJlZm9yZUluaXQiLCJfYWN0aXZlcyIsImJlZm9yZVVwZGF0ZSIsIl9saXN0ZW5lZCIsIl9kYXRhc2V0cyIsImFmdGVyRGF0YXNldFVwZGF0ZSIsImFyZ3MiLCJpc0RhdGFzZXRWaXNpYmxlIiwiZWxlbWVudHMiLCJtZXRhIiwiZ2V0RGF0YVZpc2liaWxpdHkiLCJza2lwIiwiYWN0aXZlIiwiZGF0YUluZGV4IiwibWVyZ2VyIiwic291cmNlIiwiYWZ0ZXJVcGRhdGUiLCJhZnRlckRhdGFzZXRzRHJhdyIsImJlZm9yZUV2ZW50IiwiYWZ0ZXJFdmVudCIsImFjdGl2ZXMiLCJnZXRBY3RpdmVFbGVtZW50cyIsImVsZW1lbnQiLCJyZW5kZXIiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chartjs-plugin-datalabels/dist/chartjs-plugin-datalabels.esm.js\n");

/***/ })

};
;